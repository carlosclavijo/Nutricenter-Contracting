
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>web: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/carlosclavijo/Nutricenter-Contracting/cmd/web/main.go (0.0%)</option>
				
				<option value="file1">github.com/carlosclavijo/Nutricenter-Contracting/internal/application/administrator/handlers/administrator_handler.go (0.0%)</option>
				
				<option value="file2">github.com/carlosclavijo/Nutricenter-Contracting/internal/application/administrator/handlers/create_administrator_handler.go (0.0%)</option>
				
				<option value="file3">github.com/carlosclavijo/Nutricenter-Contracting/internal/application/administrator/handlers/delete_administrator_handler.go (0.0%)</option>
				
				<option value="file4">github.com/carlosclavijo/Nutricenter-Contracting/internal/application/administrator/handlers/login_administrator_handler.go (0.0%)</option>
				
				<option value="file5">github.com/carlosclavijo/Nutricenter-Contracting/internal/application/administrator/handlers/restore_administrator_handler.go (0.0%)</option>
				
				<option value="file6">github.com/carlosclavijo/Nutricenter-Contracting/internal/application/administrator/handlers/update_administrator_handler.go (0.0%)</option>
				
				<option value="file7">github.com/carlosclavijo/Nutricenter-Contracting/internal/application/contract/handlers/contract_handler.go (0.0%)</option>
				
				<option value="file8">github.com/carlosclavijo/Nutricenter-Contracting/internal/application/contract/handlers/create_contract_handler.go (0.0%)</option>
				
				<option value="file9">github.com/carlosclavijo/Nutricenter-Contracting/internal/application/patient/handlers/create_patient_handler.go (0.0%)</option>
				
				<option value="file10">github.com/carlosclavijo/Nutricenter-Contracting/internal/application/patient/handlers/delete_patient_handler.go (0.0%)</option>
				
				<option value="file11">github.com/carlosclavijo/Nutricenter-Contracting/internal/application/patient/handlers/login_patient_handler.go (0.0%)</option>
				
				<option value="file12">github.com/carlosclavijo/Nutricenter-Contracting/internal/application/patient/handlers/patient_handler.go (0.0%)</option>
				
				<option value="file13">github.com/carlosclavijo/Nutricenter-Contracting/internal/application/patient/handlers/restore_patient_handler.go (0.0%)</option>
				
				<option value="file14">github.com/carlosclavijo/Nutricenter-Contracting/internal/application/patient/handlers/update_patient_handler.go (0.0%)</option>
				
				<option value="file15">github.com/carlosclavijo/Nutricenter-Contracting/internal/domain/abstractions/aggregate_root.go (0.0%)</option>
				
				<option value="file16">github.com/carlosclavijo/Nutricenter-Contracting/internal/domain/abstractions/domain_event.go (100.0%)</option>
				
				<option value="file17">github.com/carlosclavijo/Nutricenter-Contracting/internal/domain/abstractions/entity.go (0.0%)</option>
				
				<option value="file18">github.com/carlosclavijo/Nutricenter-Contracting/internal/domain/administrator/administrator.go (0.0%)</option>
				
				<option value="file19">github.com/carlosclavijo/Nutricenter-Contracting/internal/domain/administrator/administrator_factory.go (0.0%)</option>
				
				<option value="file20">github.com/carlosclavijo/Nutricenter-Contracting/internal/domain/contract/contract.go (0.0%)</option>
				
				<option value="file21">github.com/carlosclavijo/Nutricenter-Contracting/internal/domain/contract/contract_factory.go (0.0%)</option>
				
				<option value="file22">github.com/carlosclavijo/Nutricenter-Contracting/internal/domain/contract/contract_status.go (0.0%)</option>
				
				<option value="file23">github.com/carlosclavijo/Nutricenter-Contracting/internal/domain/contract/contract_type.go (0.0%)</option>
				
				<option value="file24">github.com/carlosclavijo/Nutricenter-Contracting/internal/domain/delivery/delivery.go (0.0%)</option>
				
				<option value="file25">github.com/carlosclavijo/Nutricenter-Contracting/internal/domain/patient/patient.go (0.0%)</option>
				
				<option value="file26">github.com/carlosclavijo/Nutricenter-Contracting/internal/domain/patient/patient_factory.go (0.0%)</option>
				
				<option value="file27">github.com/carlosclavijo/Nutricenter-Contracting/internal/domain/valueobjects/birth_date.go (0.0%)</option>
				
				<option value="file28">github.com/carlosclavijo/Nutricenter-Contracting/internal/domain/valueobjects/email.go (0.0%)</option>
				
				<option value="file29">github.com/carlosclavijo/Nutricenter-Contracting/internal/domain/valueobjects/password.go (0.0%)</option>
				
				<option value="file30">github.com/carlosclavijo/Nutricenter-Contracting/internal/domain/valueobjects/phone.go (0.0%)</option>
				
				<option value="file31">github.com/carlosclavijo/Nutricenter-Contracting/internal/infrastructure/handlers/administrator/administrator_handler.go (0.0%)</option>
				
				<option value="file32">github.com/carlosclavijo/Nutricenter-Contracting/internal/infrastructure/handlers/administrator/count_active_administrators_handler.go (0.0%)</option>
				
				<option value="file33">github.com/carlosclavijo/Nutricenter-Contracting/internal/infrastructure/handlers/administrator/count_all_administrators_handler.go (0.0%)</option>
				
				<option value="file34">github.com/carlosclavijo/Nutricenter-Contracting/internal/infrastructure/handlers/administrator/count_deleted_administrators_handler.go (0.0%)</option>
				
				<option value="file35">github.com/carlosclavijo/Nutricenter-Contracting/internal/infrastructure/handlers/administrator/exist_administrator_by_email.go (0.0%)</option>
				
				<option value="file36">github.com/carlosclavijo/Nutricenter-Contracting/internal/infrastructure/handlers/administrator/exist_administrator_by_id_handler.go (0.0%)</option>
				
				<option value="file37">github.com/carlosclavijo/Nutricenter-Contracting/internal/infrastructure/handlers/administrator/get_administrator_by_email_handler.go (0.0%)</option>
				
				<option value="file38">github.com/carlosclavijo/Nutricenter-Contracting/internal/infrastructure/handlers/administrator/get_administrator_by_id_handler.go (0.0%)</option>
				
				<option value="file39">github.com/carlosclavijo/Nutricenter-Contracting/internal/infrastructure/handlers/administrator/get_all_administrators_handler.go (0.0%)</option>
				
				<option value="file40">github.com/carlosclavijo/Nutricenter-Contracting/internal/infrastructure/handlers/administrator/get_list_administrators_handler.go (0.0%)</option>
				
				<option value="file41">github.com/carlosclavijo/Nutricenter-Contracting/internal/infrastructure/handlers/patient/count_active_patients_handler.go (0.0%)</option>
				
				<option value="file42">github.com/carlosclavijo/Nutricenter-Contracting/internal/infrastructure/handlers/patient/count_all_patients_handler.go (0.0%)</option>
				
				<option value="file43">github.com/carlosclavijo/Nutricenter-Contracting/internal/infrastructure/handlers/patient/count_deleted_patients_handler.go (0.0%)</option>
				
				<option value="file44">github.com/carlosclavijo/Nutricenter-Contracting/internal/infrastructure/handlers/patient/exist_patient_by_email.go (0.0%)</option>
				
				<option value="file45">github.com/carlosclavijo/Nutricenter-Contracting/internal/infrastructure/handlers/patient/exist_patient_by_id_handler.go (0.0%)</option>
				
				<option value="file46">github.com/carlosclavijo/Nutricenter-Contracting/internal/infrastructure/handlers/patient/get_all_patients_handler.go (0.0%)</option>
				
				<option value="file47">github.com/carlosclavijo/Nutricenter-Contracting/internal/infrastructure/handlers/patient/get_list_patients_handler.go (0.0%)</option>
				
				<option value="file48">github.com/carlosclavijo/Nutricenter-Contracting/internal/infrastructure/handlers/patient/get_patient_by_email_handler.go (0.0%)</option>
				
				<option value="file49">github.com/carlosclavijo/Nutricenter-Contracting/internal/infrastructure/handlers/patient/get_patient_by_id_handler.go (0.0%)</option>
				
				<option value="file50">github.com/carlosclavijo/Nutricenter-Contracting/internal/infrastructure/handlers/patient/patient_handler.go (0.0%)</option>
				
				<option value="file51">github.com/carlosclavijo/Nutricenter-Contracting/internal/infrastructure/persistence/database.go (0.0%)</option>
				
				<option value="file52">github.com/carlosclavijo/Nutricenter-Contracting/internal/infrastructure/persistence/repositories/administrator_repository.go (0.0%)</option>
				
				<option value="file53">github.com/carlosclavijo/Nutricenter-Contracting/internal/infrastructure/persistence/repositories/contract_repository.go (0.0%)</option>
				
				<option value="file54">github.com/carlosclavijo/Nutricenter-Contracting/internal/infrastructure/persistence/repositories/patient_repository.go (0.0%)</option>
				
				<option value="file55">github.com/carlosclavijo/Nutricenter-Contracting/internal/web/controllers/administrator_controller.go (0.0%)</option>
				
				<option value="file56">github.com/carlosclavijo/Nutricenter-Contracting/internal/web/controllers/patient_controller.go (0.0%)</option>
				
				<option value="file57">github.com/carlosclavijo/Nutricenter-Contracting/internal/web/routes.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "github.com/carlosclavijo/Nutricenter-Contracting/internal/infrastructure/persistence"
        "github.com/carlosclavijo/Nutricenter-Contracting/internal/web"
        "github.com/joho/godotenv"
        "log"
        "net/http"
)

const connection = ":8080"

func main() <span class="cov0" title="0">{
        _ = godotenv.Load("../../.env")

        db, err := persistence.NewPostgresDB()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("[web:main] database main error: %v", err)
                return
        }</span>

        <span class="cov0" title="0">routes := web.NewRoutes(db)

        err = http.ListenAndServe(connection, routes.Router())
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("[web:main] Web connection  error: %v", err)
                return
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package handlers

import "github.com/carlosclavijo/Nutricenter-Contracting/internal/domain/administrator"

type AdministratorHandler struct {
        repository administrators.AdministratorRepository
        factory    administrators.AdministratorFactory
}

func NewAdministratorHandler(r administrators.AdministratorRepository, f administrators.AdministratorFactory) *AdministratorHandler <span class="cov0" title="0">{
        return &amp;AdministratorHandler{
                repository: r,
                factory:    f,
        }
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package handlers

import (
        "context"
        "github.com/carlosclavijo/Nutricenter-Contracting/internal/application/administrator/commands"
        "github.com/carlosclavijo/Nutricenter-Contracting/internal/domain/administrator"
        "golang.org/x/crypto/bcrypt"
        "log"
)

func (h *AdministratorHandler) HandleCreate(ctx context.Context, cmd commands.CreateAdministratorCommand) (*administrators.Administrator, error) <span class="cov0" title="0">{
        password, err := bcrypt.GenerateFromPassword([]byte(cmd.Password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[handler:administrator][HandleCreate] Error generating password: %v", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">adminFactory, err := h.factory.Create(cmd.FirstName, cmd.LastName, cmd.Email, string(password), cmd.Gender, cmd.Birth, cmd.Phone)

        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[handler:administrator][HandleCreate] error Creating AdministratorFactory: %v", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">admin, err := h.repository.Create(ctx, adminFactory)

        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[handler:administrator][HandleCreate] error Creating AdministratorRepository: %v", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return admin, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package handlers

import (
        "context"
        "errors"
        "github.com/carlosclavijo/Nutricenter-Contracting/internal/domain/administrator"
        "github.com/google/uuid"
        "log"
)

func (h *AdministratorHandler) HandleDelete(ctx context.Context, id uuid.UUID) (*administrators.Administrator, error) <span class="cov0" title="0">{
        if id == uuid.Nil </span><span class="cov0" title="0">{
                log.Printf("[handler:administrator][HandleDelete] Id '%v' is nil", id)
                return nil, errors.New("the id is not valid")
        }</span>

        <span class="cov0" title="0">exist, err := h.repository.ExistById(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[handler:administrator][HandleDelete] error verifying if Administrator exists: %v", err)
                return nil, err
        }</span> else<span class="cov0" title="0"> if !exist </span><span class="cov0" title="0">{
                log.Printf("[handler:administrator][HandleDelete] the Administrator doesn't exists '%v'", id)
                return nil, errors.New("administrator not found")
        }</span>

        <span class="cov0" title="0">admin, err := h.repository.Delete(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[handler:administrator][HandleDelete] error Deleting Administrator: %v", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return admin, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package handlers

import (
        "context"
        "errors"
        "github.com/carlosclavijo/Nutricenter-Contracting/internal/application/administrator/commands"
        administrators "github.com/carlosclavijo/Nutricenter-Contracting/internal/domain/administrator"
        "github.com/carlosclavijo/Nutricenter-Contracting/internal/domain/valueobjects"
        "golang.org/x/crypto/bcrypt"
        "log"
        "time"
)

func (h *AdministratorHandler) HandleLogin(ctx context.Context, cmd commands.LoginAdministratorCommand) (*administrators.Administrator, error) <span class="cov0" title="0">{
        exist, err := h.repository.ExistByEmail(ctx, cmd.Email)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[handler:administrator][HandleLogin] error verifying if Administrator exists: %v", err)
                return nil, err
        }</span> else<span class="cov0" title="0"> if !exist </span><span class="cov0" title="0">{
                log.Printf("[handler:administrator][HandleLogin] the Administrator doesn't exist '%v'", cmd.Email)
                return nil, errors.New("administrator not found")
        }</span>

        <span class="cov0" title="0">email, err := valueobjects.NewEmail(cmd.Email)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[handler:administrator][HandleUpdate] error parsing email '%s' %v", cmd.Email, err)
                return nil, err
        }</span>

        <span class="cov0" title="0">password, err := valueobjects.NewPassword(cmd.Password)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[handler:administrator][HandleUpdate] error parsing password: %v", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">admin, err := h.repository.GetByEmail(ctx, email.Value())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err = bcrypt.CompareHashAndPassword([]byte(admin.Password().String()), []byte(password.String())); err != nil </span><span class="cov0" title="0">{
                log.Printf("[handler:administrator][HandleLogin] invalid credentials for email=%s", cmd.Email)
                return nil, errors.New("invalid credentials")
        }</span>

        <span class="cov0" title="0">admin.LastLoginAt = time.Now()
        admin, err = h.repository.Update(ctx, admin)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[handler:administrator][HandleLogin] error Updating LastLoginAt of Administrator: %v", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return admin, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package handlers

import (
        "context"
        "errors"
        "github.com/carlosclavijo/Nutricenter-Contracting/internal/domain/administrator"
        "github.com/google/uuid"
        "log"
)

func (h *AdministratorHandler) HandleRestore(ctx context.Context, id uuid.UUID) (*administrators.Administrator, error) <span class="cov0" title="0">{
        if id == uuid.Nil </span><span class="cov0" title="0">{
                log.Printf("[handler:administrator][HandleRestore] Id '%v' is nil", id)
                return nil, errors.New("the id is not valid")
        }</span>

        <span class="cov0" title="0">exist, err := h.repository.ExistById(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[handler:administrator][HandleRestore] error verifying if Administrator exists: %v", err)
                return nil, err
        }</span> else<span class="cov0" title="0"> if !exist </span><span class="cov0" title="0">{
                log.Printf("[handler:administrator][HandleRestore] the Administrator doesn't exists '%v'", id)
                return nil, errors.New("administrator not found")
        }</span>

        <span class="cov0" title="0">admin, err := h.repository.Restore(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[handler:administrator][HandleRestore] error Deleting Administrator: %v", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return admin, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package handlers

import (
        "context"
        "errors"
        "github.com/carlosclavijo/Nutricenter-Contracting/internal/application/administrator/commands"
        "github.com/carlosclavijo/Nutricenter-Contracting/internal/domain/abstractions"
        "github.com/carlosclavijo/Nutricenter-Contracting/internal/domain/administrator"
        "github.com/carlosclavijo/Nutricenter-Contracting/internal/domain/valueobjects"
        "github.com/google/uuid"
        "log"
)

func (h *AdministratorHandler) HandleUpdate(ctx context.Context, cmd commands.UpdateAdministratorCommand) (*administrators.Administrator, error) <span class="cov0" title="0">{
        exist, err := h.repository.ExistById(ctx, cmd.Id)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[handler:administrator][HandleUpdate] error verifying if Administrator exists: %v", err)
                return nil, err
        }</span> else<span class="cov0" title="0"> if !exist </span><span class="cov0" title="0">{
                log.Printf("[handler:administrator][HandleUpdate] the Administrator doesn't exist '%v'", cmd.Id)
                return nil, errors.New("administrator not found")
        }</span>

        <span class="cov0" title="0">email, err := valueobjects.NewEmail(cmd.Email)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[handler:administrator][HandleUpdate] error parsing email '%s': %v", cmd.Email, err)
                return nil, err
        }</span>

        <span class="cov0" title="0">password, err := valueobjects.NewPassword(cmd.Password)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[handler:administrator][HandleUpdate] error parsing password: %v", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">birth, err := valueobjects.NewBirthDate(cmd.Birth)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[handler:administrator][HandleUpdate] error parsing birth '%v': %v", cmd.Birth, err)
                return nil, err
        }</span>

        <span class="cov0" title="0">phone, err := valueobjects.NewPhone(cmd.Phone)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[handler:administrator][HandleUpdate] error parsing phone '%v': %v", cmd.Phone, err)
                return nil, err
        }</span>

        <span class="cov0" title="0">if cmd.Id == uuid.Nil </span><span class="cov0" title="0">{
                log.Printf("[handler:administrator][HandleUpdate] Id '%v' is nil", cmd.Id)
                return nil, err
        }</span>

        <span class="cov0" title="0">admin := administrators.NewAdministrator(cmd.FirstName, cmd.LastName, email, password, cmd.Gender, birth, phone)
        admin.AggregateRoot = abstractions.NewAggregateRoot(cmd.Id)

        admin, err = h.repository.Update(ctx, admin)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[handler:administrator][HandleUpdate] error Updating Administrator: %v", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return admin, nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package handlers

import contracts "github.com/carlosclavijo/Nutricenter-Contracting/internal/domain/contract"

type ContractHandler struct {
        repository contracts.ContractRepository
        factory    contracts.ContractFactory
}

func NewContractHandler(r contracts.ContractRepository, f contracts.ContractFactory) *ContractHandler <span class="cov0" title="0">{
        return &amp;ContractHandler{
                repository: r,
                factory:    f,
        }
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package handlers

import (
        "context"
        "github.com/carlosclavijo/Nutricenter-Contracting/internal/application/contract/commands"
        "github.com/carlosclavijo/Nutricenter-Contracting/internal/domain/contract"
        "log"
)

func (h *ContractHandler) HandleCreate(ctx context.Context, cmd commands.CreateContractCommand) (*contracts.Contract, error) <span class="cov0" title="0">{
        cType, err := contracts.ParseContractType(cmd.ContractType)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[handler:contract][HandleCreate] error parsing contract type: %v", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">contractFactory, err := h.factory.Create(cmd.AdministratorId, cmd.PatientId, cType, cmd.StartDate, cmd.Cost, cmd.Street, cmd.Number)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[handler:contract][HandleCreate] error creating contract: %v", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return contractFactory, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package handlers

import (
        "context"
        "github.com/carlosclavijo/Nutricenter-Contracting/internal/application/patient/commands"
        "github.com/carlosclavijo/Nutricenter-Contracting/internal/domain/patient"
        "golang.org/x/crypto/bcrypt"
        "log"
)

func (h *PatientHandler) HandleCreate(ctx context.Context, cmd commands.CreatePatientCommand) (*patients.Patient, error) <span class="cov0" title="0">{
        password, err := bcrypt.GenerateFromPassword([]byte(cmd.Password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[handler:patient][HandleCreate] Error generating password: %v", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">patientFactory, err := h.factory.Create(cmd.FirstName, cmd.LastName, cmd.Email, string(password), cmd.Gender, cmd.Birth, cmd.Phone)

        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[handler:patient][HandleCreate] error Creating PatientFactory: %v", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">admin, err := h.repository.Create(ctx, patientFactory)

        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[handler:patient][HandleCreate] error Creating PatientRepository: %v", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return admin, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package handlers

import (
        "context"
        "errors"
        "github.com/carlosclavijo/Nutricenter-Contracting/internal/domain/patient"
        "github.com/google/uuid"
        "log"
)

func (h *PatientHandler) HandleDelete(ctx context.Context, id uuid.UUID) (*patients.Patient, error) <span class="cov0" title="0">{
        if id == uuid.Nil </span><span class="cov0" title="0">{
                log.Printf("[handler:patient][HandleDelete] Id '%v' is nil", id)
                return nil, errors.New("the id is not valid")
        }</span>

        <span class="cov0" title="0">exist, err := h.repository.ExistById(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[handler:patient][HandleDelete] error verifying if Patient exists: %v", err)
                return nil, err
        }</span> else<span class="cov0" title="0"> if !exist </span><span class="cov0" title="0">{
                log.Printf("[handler:patient][HandleDelete] the Patient doesn't exists '%v'", id)
                return nil, errors.New("patient not found")
        }</span>

        <span class="cov0" title="0">admin, err := h.repository.Delete(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[handler:patient][HandleDelete] error Deleting Patient: %v", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return admin, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package handlers

import (
        "context"
        "errors"
        "github.com/carlosclavijo/Nutricenter-Contracting/internal/application/patient/commands"
        "github.com/carlosclavijo/Nutricenter-Contracting/internal/domain/patient"
        "github.com/carlosclavijo/Nutricenter-Contracting/internal/domain/valueobjects"
        "golang.org/x/crypto/bcrypt"
        "log"
        "time"
)

func (h *PatientHandler) HandleLogin(ctx context.Context, cmd commands.LoginPatientCommand) (*patients.Patient, error) <span class="cov0" title="0">{
        exist, err := h.repository.ExistByEmail(ctx, cmd.Email)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[handler:patient][HandleLogin] error verifying if patient exists: %v", err)
                return nil, err
        }</span> else<span class="cov0" title="0"> if !exist </span><span class="cov0" title="0">{
                log.Printf("[handler:patient][HandleLogin] the Patient doesn't exist '%v'", cmd.Email)
                return nil, errors.New("patient not found")
        }</span>

        <span class="cov0" title="0">email, err := valueobjects.NewEmail(cmd.Email)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[handler:patient][HandleUpdate] error parsing email '%s' %v", cmd.Email, err)
                return nil, err
        }</span>

        <span class="cov0" title="0">password, err := valueobjects.NewPassword(cmd.Password)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[handler:patient][HandleUpdate] error parsing password: %v", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">patient, err := h.repository.GetByEmail(ctx, email.Value())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err = bcrypt.CompareHashAndPassword([]byte(patient.Password().String()), []byte(password.String())); err != nil </span><span class="cov0" title="0">{
                log.Printf("[handler:patient][HandleLogin] invalid credentials for email=%s", cmd.Email)
                return nil, errors.New("invalid credentials")
        }</span>

        <span class="cov0" title="0">patient.LastLoginAt = time.Now()
        patient, err = h.repository.Update(ctx, patient)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[handler:patient][HandleLogin] error Updating LastLoginAt of Patient: %v", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return patient, nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package handlers

import "github.com/carlosclavijo/Nutricenter-Contracting/internal/domain/patient"

type PatientHandler struct {
        repository patients.PatientRepository
        factory    patients.PatientFactory
}

func NewPatientHandler(r patients.PatientRepository, f patients.PatientFactory) *PatientHandler <span class="cov0" title="0">{
        return &amp;PatientHandler{
                repository: r,
                factory:    f,
        }
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package handlers

import (
        "context"
        "errors"
        "github.com/carlosclavijo/Nutricenter-Contracting/internal/domain/patient"
        "github.com/google/uuid"
        "log"
)

func (h *PatientHandler) HandleRestore(ctx context.Context, id uuid.UUID) (*patients.Patient, error) <span class="cov0" title="0">{
        if id == uuid.Nil </span><span class="cov0" title="0">{
                log.Printf("[handler:patient][HandleRestore] Id '%v' is nil", id)
                return nil, errors.New("the id is not valid")
        }</span>

        <span class="cov0" title="0">exist, err := h.repository.ExistById(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[handler:patient][HandleRestore] error verifying if Patient exists: %v", err)
                return nil, err
        }</span> else<span class="cov0" title="0"> if !exist </span><span class="cov0" title="0">{
                log.Printf("[handler:patient][HandleRestore] the Patient doesn't exists '%v'", id)
                return nil, errors.New("patient not found")
        }</span>

        <span class="cov0" title="0">admin, err := h.repository.Restore(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[handler:patient][HandleRestore] error Deleting Patient: %v", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return admin, nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package handlers

import (
        "context"
        "errors"
        "github.com/carlosclavijo/Nutricenter-Contracting/internal/application/patient/commands"
        "github.com/carlosclavijo/Nutricenter-Contracting/internal/domain/abstractions"
        "github.com/carlosclavijo/Nutricenter-Contracting/internal/domain/patient"
        "github.com/carlosclavijo/Nutricenter-Contracting/internal/domain/valueobjects"
        "github.com/google/uuid"
        "log"
)

func (h *PatientHandler) HandleUpdate(ctx context.Context, cmd commands.UpdatePatientCommand) (*patients.Patient, error) <span class="cov0" title="0">{
        exist, err := h.repository.ExistById(ctx, cmd.Id)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[handler:patient][HandleUpdate] error verifying if Patient exists: %v", err)
                return nil, err
        }</span> else<span class="cov0" title="0"> if !exist </span><span class="cov0" title="0">{
                log.Printf("[handler:patient][HandleUpdate] the Patient doesn't exist '%v'", cmd.Id)
                return nil, errors.New("patient not found")
        }</span>

        <span class="cov0" title="0">email, err := valueobjects.NewEmail(cmd.Email)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[handler:patient][HandleUpdate] error parsing email: %v", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">password, err := valueobjects.NewPassword(cmd.Password)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[handler:patient][HandleUpdate] error parsing password: %v", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">birth, err := valueobjects.NewBirthDate(cmd.Birth)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[handler:patient][HandleUpdate] error parsing birth: %v", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">phone, err := valueobjects.NewPhone(cmd.Phone)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[handler:patient][HandleUpdate] error parsing phone: %v", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">if cmd.Id == uuid.Nil </span><span class="cov0" title="0">{
                log.Printf("[handler:patient][HandleUpdate] Id '%v' is nil", cmd.Id)
                return nil, err
        }</span>

        <span class="cov0" title="0">patient := patients.NewPatient(cmd.FirstName, cmd.LastName, email, password, cmd.Gender, birth, phone)
        patient.AggregateRoot = abstractions.NewAggregateRoot(cmd.Id)

        patient, err = h.repository.Update(ctx, patient)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[handler:patient][HandleUpdate] error Updating Patient: %v", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return patient, nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package abstractions

import "github.com/google/uuid"

type AggregateRoot struct {
        *Entity
}

func NewAggregateRoot(id uuid.UUID) *AggregateRoot <span class="cov0" title="0">{
        return &amp;AggregateRoot{NewEntity(id)}
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package abstractions

import (
        "github.com/google/uuid"
        "time"
)

type DomainEvent struct {
        id         uuid.UUID
        occurredOn time.Time
}

func NewDomainEvent() *DomainEvent <span class="cov8" title="1">{
        return &amp;DomainEvent{
                id:         uuid.New(),
                occurredOn: time.Now(),
        }
}</span>

func (d *DomainEvent) Id() uuid.UUID <span class="cov8" title="1">{
        return d.id
}</span>

func (d *DomainEvent) OccurredOn() time.Time <span class="cov8" title="1">{
        return d.occurredOn
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package abstractions

import (
        "github.com/google/uuid"
)

type Entity struct {
        Id           uuid.UUID
        domainEvents []DomainEvent
}

func NewEntity(id uuid.UUID) *Entity <span class="cov0" title="0">{
        return &amp;Entity{
                Id:           id,
                domainEvents: []DomainEvent{},
        }
}</span>

func (e *Entity) AddDomainEvent(event DomainEvent) <span class="cov0" title="0">{
        e.domainEvents = append(e.domainEvents, event)
}</span>

func (e *Entity) ClearDomainEvents() <span class="cov0" title="0">{
        e.domainEvents = nil
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package administrators

import (
        "github.com/carlosclavijo/Nutricenter-Contracting/internal/domain/abstractions"
        vo "github.com/carlosclavijo/Nutricenter-Contracting/internal/domain/valueobjects"
        "github.com/google/uuid"
        "time"
)

type Administrator struct {
        *abstractions.AggregateRoot
        firstName   string
        lastName    string
        email       vo.Email
        password    vo.Password
        gender      string
        birth       *vo.BirthDate
        phone       *vo.Phone
        LastLoginAt time.Time
        createdAt   time.Time
        UpdatedAt   time.Time
        DeletedAt   *time.Time
}

func NewAdministrator(firstName, lastName string, email vo.Email, password vo.Password, gender string, birth *vo.BirthDate, phone *vo.Phone) *Administrator <span class="cov0" title="0">{
        return &amp;Administrator{
                AggregateRoot: abstractions.NewAggregateRoot(uuid.New()),
                firstName:     firstName,
                lastName:      lastName,
                email:         email,
                password:      password,
                gender:        gender,
                birth:         birth,
                phone:         phone,
        }
}</span>

func (admin *Administrator) Id() uuid.UUID <span class="cov0" title="0">{
        return admin.Entity.Id
}</span>

func (admin *Administrator) FirstName() string <span class="cov0" title="0">{
        return admin.firstName
}</span>

func (admin *Administrator) LastName() string <span class="cov0" title="0">{
        return admin.lastName
}</span>

func (admin *Administrator) Email() vo.Email <span class="cov0" title="0">{
        return admin.email
}</span>

func (admin *Administrator) Password() vo.Password <span class="cov0" title="0">{
        return admin.password
}</span>

func (admin *Administrator) Gender() string <span class="cov0" title="0">{
        return admin.gender
}</span>

func (admin *Administrator) Birth() *vo.BirthDate <span class="cov0" title="0">{
        return admin.birth
}</span>

func (admin *Administrator) Phone() *vo.Phone <span class="cov0" title="0">{
        return admin.phone
}</span>

func (admin *Administrator) CreatedAt() time.Time <span class="cov0" title="0">{
        return admin.createdAt
}</span>

func NewAdministratorFromDB(id uuid.UUID, firstName, lastName, email, password, gender string, birth *time.Time, phone *string, lastLoginAt, createdAt, updatedAt time.Time, deletedAt *time.Time) *Administrator <span class="cov0" title="0">{
        emailVo, _ := vo.NewEmail(email)
        passwordVo, _ := vo.NewPassword(password)
        birthVo, _ := vo.NewBirthDate(birth)
        phoneVo, _ := vo.NewPhone(phone)

        return &amp;Administrator{
                AggregateRoot: abstractions.NewAggregateRoot(id),
                firstName:     firstName,
                lastName:      lastName,
                email:         emailVo,
                password:      passwordVo,
                gender:        gender,
                birth:         birthVo,
                phone:         phoneVo,
                LastLoginAt:   lastLoginAt,
                createdAt:     createdAt,
                UpdatedAt:     updatedAt,
                DeletedAt:     deletedAt,
        }
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package administrators

import (
        "errors"
        "github.com/carlosclavijo/Nutricenter-Contracting/internal/domain/valueobjects"
        "log"
        "time"
        "unicode"
)

type AdministratorFactory interface {
        Create(firstName, lastName, email, password, gender string, birth *time.Time, phone *string) (*Administrator, error)
}

type administratorFactory struct{}

func (a administratorFactory) Create(firstName, lastName, email, password, gender string, birth *time.Time, phone *string) (*Administrator, error) <span class="cov0" title="0">{
        if firstName == "" </span><span class="cov0" title="0">{
                log.Printf("[factory:administrator] firstName '%s' is empty", firstName)
                return nil, errors.New("firstName is empty")
        }</span>
        <span class="cov0" title="0">if lastName == "" </span><span class="cov0" title="0">{
                log.Printf("[factory:administrator] lastName '%s' is empty", lastName)
                return nil, errors.New("lastName is empty")
        }</span>
        <span class="cov0" title="0">if gender == "" </span><span class="cov0" title="0">{
                log.Printf("[factory:administrator] gender '%s' is empty", gender)
                return nil, errors.New("gender is empty")
        }</span>

        <span class="cov0" title="0">emailVO, err := valueobjects.NewEmail(email)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[factory:administrator] Error creating email '%s' object: %v", email, err)
                return nil, err
        }</span>
        <span class="cov0" title="0">passwordVO, err := valueobjects.NewPassword(password)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[factory:administrator] Error creating password object: %v", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">birthVO, err := valueobjects.NewBirthDate(birth)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[factory:administrator] Error creating birth date '%v' object: %v", birth, err)
                return nil, err
        }</span>
        <span class="cov0" title="0">phoneVO, err := valueobjects.NewPhone(phone)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[factory:administrator] Error creating phone '%d' object: %v", phone, err)
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(firstName) &gt; 100 </span><span class="cov0" title="0">{
                log.Printf("[factory:administrator] firstName '%s' is too long (length %d, maximum is 100)", firstName, len(firstName))
                return nil, errors.New("firstName is too long: maximum length is 100 characters")
        }</span>
        <span class="cov0" title="0">if len(lastName) &gt; 100 </span><span class="cov0" title="0">{
                log.Printf("[factory:administrator] lastName '%s' is too long (length %d, maximum is 100)", lastName, len(lastName))
                return nil, errors.New("lastName is too long: maximum length is 100 characters")
        }</span>
        <span class="cov0" title="0">if len(gender) != 1 </span><span class="cov0" title="0">{
                log.Printf("[factory:administrator] gender: '%v' can only be one character", gender)
                return nil, errors.New("gender isn't only one character")
        }</span>
        <span class="cov0" title="0">if gender != "M" &amp;&amp; gender != "F" &amp;&amp; gender != "U" </span><span class="cov0" title="0">{
                log.Printf("[factory:administrator] gender: '%v' can only be 'M', 'F' or 'U'", gender)
                return nil, errors.New("gender is only 'M', 'F' or 'U'")
        }</span>
        <span class="cov0" title="0">if !isAlpha(firstName) </span><span class="cov0" title="0">{
                log.Printf("[factory:administrator] firstName '%s' contains non-alphabetic characters", firstName)
                return nil, errors.New("firstName contains non-alphabetic characters")
        }</span>
        <span class="cov0" title="0">if !isAlpha(lastName) </span><span class="cov0" title="0">{
                log.Printf("[factory:administrator] lastName '%s' contains non-alphabetic characters", lastName)
                return nil, errors.New("lastName contains non-alphabetic characters")
        }</span>
        <span class="cov0" title="0">log.Printf("[factory:administrator][SUCCESS] administrator created")
        return NewAdministrator(firstName, lastName, emailVO, passwordVO, gender, birthVO, phoneVO), nil</span>
}

func NewAdministratorFactory() AdministratorFactory <span class="cov0" title="0">{
        return &amp;administratorFactory{}
}</span>

func isAlpha(s string) bool <span class="cov0" title="0">{
        for _, r := range s </span><span class="cov0" title="0">{
                if !unicode.IsLetter(r) || r == ' ' </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package contracts

import (
        "errors"
        "github.com/carlosclavijo/Nutricenter-Contracting/internal/domain/abstractions"
        "github.com/carlosclavijo/Nutricenter-Contracting/internal/domain/delivery"
        "github.com/google/uuid"
        "time"
)

type Contract struct {
        *abstractions.AggregateRoot
        administratorId uuid.UUID
        patientId       uuid.UUID
        contractType    ContractType
        contractStatus  ContractStatus
        creationDate    time.Time
        startDate       time.Time
        endDate         *time.Time
        costValue       int
        deliveries      []deliveries.Delivery
        createdAt       time.Time
        updatedAt       time.Time
        deletedAt       *time.Time
}

func NewContract(administratorId uuid.UUID, patientId uuid.UUID, contractType ContractType, start time.Time, costValue int, street string, number int) *Contract <span class="cov0" title="0">{
        id := uuid.New()
        return &amp;Contract{
                AggregateRoot:   abstractions.NewAggregateRoot(id),
                administratorId: administratorId,
                patientId:       patientId,
                contractType:    contractType,
                contractStatus:  Created,
                creationDate:    time.Now(),
                startDate:       start,
                costValue:       costValue,
                deliveries:      createCalendar(contractType, id, start, street, number),
        }
}</span>

func createCalendar(typ ContractType, contractId uuid.UUID, date time.Time, street string, number int) []deliveries.Delivery <span class="cov0" title="0">{
        var days []deliveries.Delivery
        if typ == HalfMonth </span><span class="cov0" title="0">{
                for i := 0; i &lt; 15; i++ </span><span class="cov0" title="0">{
                        d := deliveries.NewDelivery(contractId, date.AddDate(0, 0, 0+i), street, number)
                        days = append(days, *d)
                }</span>
        } else<span class="cov0" title="0"> if typ == Monthly </span><span class="cov0" title="0">{
                for i := 0; i &lt; 30; i++ </span><span class="cov0" title="0">{
                        d := deliveries.NewDelivery(contractId, date.AddDate(0, 0, 0+i), street, number)
                        days = append(days, *d)
                }</span>
        }
        <span class="cov0" title="0">return days</span>
}

func (c *Contract) InProgress() error <span class="cov0" title="0">{
        if c.contractStatus != Created </span><span class="cov0" title="0">{
                return errors.New("contract is not created")
        }</span>
        <span class="cov0" title="0">c.contractStatus = InProgress
        return nil</span>
}

func (c *Contract) Completed() error <span class="cov0" title="0">{
        if c.contractStatus != InProgress </span><span class="cov0" title="0">{
                return errors.New("contract is not in-progress")
        }</span>
        <span class="cov0" title="0">c.contractStatus = Completed
        return nil</span>
}

func (c *Contract) Id() uuid.UUID <span class="cov0" title="0">{
        return c.Entity.Id
}</span>

func (c *Contract) AdministratorId() uuid.UUID <span class="cov0" title="0">{
        return c.administratorId
}</span>

func (c *Contract) PatientId() uuid.UUID <span class="cov0" title="0">{
        return c.patientId
}</span>

func (c *Contract) ContractType() ContractType <span class="cov0" title="0">{
        return c.contractType
}</span>

func (c *Contract) ContractStatus() ContractStatus <span class="cov0" title="0">{
        return c.contractStatus
}</span>

func (c *Contract) CreationDate() time.Time <span class="cov0" title="0">{
        return c.creationDate
}</span>

func (c *Contract) StartDate() time.Time <span class="cov0" title="0">{
        return c.startDate
}</span>

func (c *Contract) EndDate() *time.Time <span class="cov0" title="0">{
        return c.endDate
}</span>

func (c *Contract) CostValue() int <span class="cov0" title="0">{
        return c.costValue
}</span>

func (c *Contract) Deliveries() []deliveries.Delivery <span class="cov0" title="0">{
        return c.deliveries
}</span>

func NewContractFromDb(id, aId, pId uuid.UUID, cType ContractType, cStatus ContractStatus, cDate, sDate time.Time, eDate *time.Time, cost int, cAt, uAt time.Time, dAt *time.Time) *Contract <span class="cov0" title="0">{
        return &amp;Contract{
                AggregateRoot:   abstractions.NewAggregateRoot(id),
                administratorId: aId,
                patientId:       pId,
                contractType:    cType,
                contractStatus:  cStatus,
                creationDate:    cDate,
                startDate:       sDate,
                endDate:         eDate,
                costValue:       cost,
                deliveries:      []deliveries.Delivery{},
                createdAt:       cAt,
                updatedAt:       uAt,
                deletedAt:       dAt,
        }
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package contracts

import (
        "errors"
        "github.com/google/uuid"
        "log"
        "time"
)

type ContractFactory interface {
        Create(administratorId, patientId uuid.UUID, contractType ContractType, start time.Time, cost int, street string, number int) (*Contract, error)
}

type contractFactory struct{}

func (c contractFactory) Create(administratorId, patientId uuid.UUID, contractType ContractType, start time.Time, cost int, street string, number int) (*Contract, error) <span class="cov0" title="0">{
        if administratorId == uuid.Nil </span><span class="cov0" title="0">{
                log.Printf("[factory:contract] administratorId '%s' is not a valid UUID", administratorId)
                return nil, errors.New("administratorId is not a valid UUID")
        }</span>
        <span class="cov0" title="0">if patientId == uuid.Nil </span><span class="cov0" title="0">{
                log.Printf("[factory:contract] patientId '%s' is not a valid UUID", patientId)
                return nil, errors.New("patientId is not a valid UUID")
        }</span>
        <span class="cov0" title="0">if contractType == "" </span><span class="cov0" title="0">{
                log.Printf("[factory:contract] contractType '%s' is empty", contractType)
                return nil, errors.New("contractType is empty")
        }</span>
        <span class="cov0" title="0">if contractType != HalfMonth &amp;&amp; contractType != Monthly </span><span class="cov0" title="0">{
                log.Printf("[factory:contract] contractType '%s' is invalid", contractType)
                return nil, errors.New("contractType is invalid")
        }</span>
        <span class="cov0" title="0">if !isAtLeastTwoDaysFromToday(start) </span><span class="cov0" title="0">{
                log.Printf("[factory:contract] startDate '%s' is before it could be", contractType)
                return nil, errors.New("startDate is not before two days after tomorrow")
        }</span>
        <span class="cov0" title="0">if cost &lt;= 0 </span><span class="cov0" title="0">{
                log.Printf("[factory:contract] cost '%v' suppose to be a positive number", contractType)
                return nil, errors.New("cost '%d' suppose to be a positive number")
        }</span>
        <span class="cov0" title="0">if street == "" </span><span class="cov0" title="0">{
                log.Printf("[factory:contract] street '%s' is empty", street)
                return nil, errors.New("street is empty")
        }</span>
        <span class="cov0" title="0">if number &lt;= 0 </span><span class="cov0" title="0">{
                log.Printf("[factory:contract] number '%d' needs to be a positive number", number)
                return nil, errors.New("number needs to be a positive number")
        }</span>
        <span class="cov0" title="0">log.Printf("[factory:contract] contractType '%s' is valid", contractType)
        return NewContract(administratorId, patientId, contractType, start, cost, street, number), nil</span>
}

func isAtLeastTwoDaysFromToday(date time.Time) bool <span class="cov0" title="0">{
        today := time.Now()
        todayDate := time.Date(today.Year(), today.Month(), today.Day(), 0, 0, 0, 0, today.Location())
        targetDate := time.Date(date.Year(), date.Month(), date.Day(), 0, 0, 0, 0, date.Location())

        daysDiff := int(targetDate.Sub(todayDate).Hours() / 24)
        return daysDiff &gt;= 2
}</span>

func NewContractFactory() ContractFactory <span class="cov0" title="0">{
        return &amp;contractFactory{}
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package contracts

import "fmt"

type ContractStatus string

const (
        Created    ContractStatus = "created"
        InProgress ContractStatus = "active"
        Completed  ContractStatus = "completed"
)

func ParseContractStatus(s string) (ContractStatus, error) <span class="cov0" title="0">{
        switch s </span>{
        case "created":<span class="cov0" title="0">
                return Created, nil</span>
        case "inprogress":<span class="cov0" title="0">
                return InProgress, nil</span>
        case "completed":<span class="cov0" title="0">
                return Completed, nil</span>
        default:<span class="cov0" title="0">
                return "", fmt.Errorf("invalid contract status: %s", s)</span>
        }
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package contracts

import (
        "fmt"
)

type ContractType string

const (
        Monthly   ContractType = "monthly"
        HalfMonth ContractType = "half-month"
)

func ParseContractType(s string) (ContractType, error) <span class="cov0" title="0">{
        switch s </span>{
        case "monthly":<span class="cov0" title="0">
                return Monthly, nil</span>
        case "half-month":<span class="cov0" title="0">
                return HalfMonth, nil</span>
        default:<span class="cov0" title="0">
                return "", fmt.Errorf("invalid contract type '%s'", s)</span>
        }
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package deliveries

import (
        "github.com/carlosclavijo/Nutricenter-Contracting/internal/domain/abstractions"
        "github.com/google/uuid"
        "time"
)

type Delivery struct {
        *abstractions.Entity
        contractId uuid.UUID
        date       time.Time
        street     string
        number     int
        createdAt  time.Time
        updatedAt  time.Time
        deletedAt  *time.Time
}

func NewDelivery(contractId uuid.UUID, date time.Time, street string, number int) *Delivery <span class="cov0" title="0">{
        return &amp;Delivery{
                Entity:     abstractions.NewEntity(uuid.New()),
                contractId: contractId,
                date:       date,
                street:     street,
                number:     number,
        }
}</span>

func (d *Delivery) Id() uuid.UUID <span class="cov0" title="0">{
        return d.Entity.Id
}</span>

func (d *Delivery) ContractId() uuid.UUID <span class="cov0" title="0">{
        return d.contractId
}</span>

func (d *Delivery) Date() time.Time <span class="cov0" title="0">{
        return d.date
}</span>

func (d *Delivery) String() string <span class="cov0" title="0">{
        return d.street
}</span>

func (d *Delivery) Number() int <span class="cov0" title="0">{
        return d.number
}</span>

func (d *Delivery) Update(street string, number int) <span class="cov0" title="0">{
        d.street = street
        d.number = number
}</span>

func (d *Delivery) Delete() {<span class="cov0" title="0">

}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package patients

import (
        "github.com/carlosclavijo/Nutricenter-Contracting/internal/domain/abstractions"
        vo "github.com/carlosclavijo/Nutricenter-Contracting/internal/domain/valueobjects"
        "github.com/google/uuid"
        "time"
)

type Patient struct {
        *abstractions.AggregateRoot
        firstName   string
        lastName    string
        email       vo.Email
        password    vo.Password
        gender      string
        birth       *vo.BirthDate
        phone       *vo.Phone
        LastLoginAt time.Time
        createdAt   time.Time
        UpdatedAt   time.Time
        DeletedAt   *time.Time
}

func NewPatient(firstName, lastName string, email vo.Email, password vo.Password, gender string, birth *vo.BirthDate, phone *vo.Phone) *Patient <span class="cov0" title="0">{
        return &amp;Patient{
                AggregateRoot: abstractions.NewAggregateRoot(uuid.New()),
                firstName:     firstName,
                lastName:      lastName,
                email:         email,
                password:      password,
                gender:        gender,
                birth:         birth,
                phone:         phone,
        }
}</span>

func (admin *Patient) Id() uuid.UUID <span class="cov0" title="0">{
        return admin.Entity.Id
}</span>

func (admin *Patient) FirstName() string <span class="cov0" title="0">{
        return admin.firstName
}</span>

func (admin *Patient) LastName() string <span class="cov0" title="0">{
        return admin.lastName
}</span>

func (admin *Patient) Email() vo.Email <span class="cov0" title="0">{
        return admin.email
}</span>

func (admin *Patient) Password() vo.Password <span class="cov0" title="0">{
        return admin.password
}</span>

func (admin *Patient) Gender() string <span class="cov0" title="0">{
        return admin.gender
}</span>

func (admin *Patient) Birth() *vo.BirthDate <span class="cov0" title="0">{
        return admin.birth
}</span>

func (admin *Patient) Phone() *vo.Phone <span class="cov0" title="0">{
        return admin.phone
}</span>

func (admin *Patient) CreatedAt() time.Time <span class="cov0" title="0">{
        return admin.createdAt
}</span>

func NewPatientFromDB(id uuid.UUID, firstName, lastName, email, password, gender string, birth *time.Time, phone *string, lastLoginAt, createdAt, updatedAt time.Time, deletedAt *time.Time) *Patient <span class="cov0" title="0">{
        emailVo, _ := vo.NewEmail(email)
        passwordVo, _ := vo.NewPassword(password)
        birthVo, _ := vo.NewBirthDate(birth)
        phoneVo, _ := vo.NewPhone(phone)

        return &amp;Patient{
                AggregateRoot: abstractions.NewAggregateRoot(id),
                firstName:     firstName,
                lastName:      lastName,
                email:         emailVo,
                password:      passwordVo,
                gender:        gender,
                birth:         birthVo,
                phone:         phoneVo,
                LastLoginAt:   lastLoginAt,
                createdAt:     createdAt,
                UpdatedAt:     updatedAt,
                DeletedAt:     deletedAt,
        }
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package patients

import (
        "errors"
        "github.com/carlosclavijo/Nutricenter-Contracting/internal/domain/valueobjects"
        "log"
        "time"
        "unicode"
)

type PatientFactory interface {
        Create(firstName, lastName, email, password, gender string, birth *time.Time, phone *string) (*Patient, error)
}

type patientFactory struct{}

func (a patientFactory) Create(firstName, lastName, email, password, gender string, birth *time.Time, phone *string) (*Patient, error) <span class="cov0" title="0">{
        if firstName == "" </span><span class="cov0" title="0">{
                log.Printf("[factory:patient] firstName '%s' is empty", firstName)
                return nil, errors.New("firstName is empty")
        }</span>
        <span class="cov0" title="0">if lastName == "" </span><span class="cov0" title="0">{
                log.Printf("[factory:patient] lastName '%s' is empty", lastName)
                return nil, errors.New("lastName is empty")
        }</span>
        <span class="cov0" title="0">if gender == "" </span><span class="cov0" title="0">{
                log.Printf("[factory:patient] gender '%s' is empty", gender)
                return nil, errors.New("gender is empty")
        }</span>

        <span class="cov0" title="0">emailVO, err := valueobjects.NewEmail(email)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[factory:patient] Error creating email '%s' object: %v", email, err)
                return nil, err
        }</span>
        <span class="cov0" title="0">passwordVO, err := valueobjects.NewPassword(password)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[factory:patient] Error creating password object: %v", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">birthVO, err := valueobjects.NewBirthDate(birth)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[factory:patient] Error creating birth date '%v' object: %v", birth, err)
                return nil, err
        }</span>
        <span class="cov0" title="0">phoneVO, err := valueobjects.NewPhone(phone)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[factory:patient] Error creating phone '%d' object: %v", phone, err)
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(firstName) &gt; 100 </span><span class="cov0" title="0">{
                log.Printf("[factory:patient] firstName '%s' is too long (length %d, maximum is 100)", firstName, len(firstName))
                return nil, errors.New("firstName is too long: maximum length is 100 characters")
        }</span>
        <span class="cov0" title="0">if len(lastName) &gt; 100 </span><span class="cov0" title="0">{
                log.Printf("[factory:patient] lastName '%s' is too long (length %d, maximum is 100)", lastName, len(lastName))
                return nil, errors.New("lastName is too long: maximum length is 100 characters")
        }</span>
        <span class="cov0" title="0">if len(gender) != 1 </span><span class="cov0" title="0">{
                log.Printf("[factory:patient] gender: '%v' can only be one character", gender)
                return nil, errors.New("gender isn't only one character")
        }</span>
        <span class="cov0" title="0">if gender != "M" &amp;&amp; gender != "F" &amp;&amp; gender != "U" </span><span class="cov0" title="0">{
                log.Printf("[factory:patient] gender: '%v' can only be 'M', 'F' or 'U'", gender)
                return nil, errors.New("gender is only 'M', 'F' or 'U'")
        }</span>
        <span class="cov0" title="0">if !isAlpha(firstName) </span><span class="cov0" title="0">{
                log.Printf("[factory:patient] firstName '%s' contains non-alphabetic characters", firstName)
                return nil, errors.New("firstName contains non-alphabetic characters")
        }</span>
        <span class="cov0" title="0">if !isAlpha(lastName) </span><span class="cov0" title="0">{
                log.Printf("[factory:patient] lastName '%s' contains non-alphabetic characters", lastName)
                return nil, errors.New("lastName contains non-alphabetic characters")
        }</span>
        <span class="cov0" title="0">log.Printf("[factory:patient][SUCCESS] patient created")
        return NewPatient(firstName, lastName, emailVO, passwordVO, gender, birthVO, phoneVO), nil</span>
}

func NewPatientFactory() PatientFactory <span class="cov0" title="0">{
        return &amp;patientFactory{}
}</span>

func isAlpha(s string) bool <span class="cov0" title="0">{
        for _, r := range s </span><span class="cov0" title="0">{
                if !unicode.IsLetter(r) || r == ' ' </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package valueobjects

import (
        "errors"
        "log"
        "time"
)

type BirthDate struct {
        value *time.Time
}

func NewBirthDate(v *time.Time) (*BirthDate, error) <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span> else<span class="cov0" title="0"> if v.After(time.Now()) </span><span class="cov0" title="0">{
                log.Printf("[valueobject:birth_date] birthdate cannot be in the future")
                return nil, errors.New("birthdate cannot be in the future")
        }</span> else<span class="cov0" title="0"> if !isAnAdult(*v) </span><span class="cov0" title="0">{
                log.Printf("[valueobject:birth_date] cannot be an underage")
                return &amp;BirthDate{}, errors.New("isn't an adult")
        }</span>
        <span class="cov0" title="0">return &amp;BirthDate{value: v}, nil</span>
}

func (b BirthDate) Value() *time.Time <span class="cov0" title="0">{
        if b.value == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return b.value</span>
}

func isAnAdult(v time.Time) bool <span class="cov0" title="0">{
        yearsAgo := time.Now().AddDate(-18, 0, 0)
        return !v.After(yearsAgo)
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">package valueobjects

import (
        "errors"
        "log"
        "regexp"
)

type Email struct {
        value string
}

func NewEmail(v string) (Email, error) <span class="cov0" title="0">{
        if v == "" </span><span class="cov0" title="0">{
                log.Printf("[valueobjects][email] empty string")
                return Email{}, errors.New("email cannot be empty")
        }</span>
        <span class="cov0" title="0">if !isValidEmail(v) </span><span class="cov0" title="0">{
                log.Printf("[valueobjects][email] Email is invalid")
                return Email{}, errors.New("invalid email")
        }</span> else<span class="cov0" title="0"> if len(v) &gt; 200 </span><span class="cov0" title="0">{
                log.Printf("[valueobjects][email] Email is too long")
                return Email{}, errors.New("email too long: max 200 characters")
        }</span>
        <span class="cov0" title="0">return Email{value: v}, nil</span>
}

func (e Email) Value() string <span class="cov0" title="0">{
        return e.value
}</span>

func isValidEmail(email string) bool <span class="cov0" title="0">{
        var emailRegex = regexp.MustCompile(`^[a-zA-Z0-9._%+\-]+@[a-zA-Z0-9.\-]+\.[a-zA-Z]{2,}$`)
        return emailRegex.MatchString(email)
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">package valueobjects

import (
        "errors"
        "log"
        "regexp"
)

type Password struct {
        value string
}

func NewPassword(v string) (Password, error) <span class="cov0" title="0">{
        if v == "" </span><span class="cov0" title="0">{
                log.Printf("[valueobject:password] empty string")
                return Password{}, errors.New("password cannot be empty")
        }</span> else<span class="cov0" title="0"> if len(v) &gt; 64 </span><span class="cov0" title="0">{
                log.Printf("[valueobject:password] password too long")
                return Password{}, errors.New("password is too long: maximum 64 characters")
        }</span> else<span class="cov0" title="0"> if len(v) &lt; 8 </span><span class="cov0" title="0">{
                log.Printf("[valueobject:password] password too short")
                return Password{}, errors.New("password is too short: minimum 8 characters")
        }</span> else<span class="cov0" title="0"> if !isStrongPassword(v) </span><span class="cov0" title="0">{
                log.Printf("[valueobject:password] password too soft")
                return Password{}, errors.New("password isn't too strong")
        }</span>
        <span class="cov0" title="0">return Password{v}, nil</span>
}

func (p Password) String() string <span class="cov0" title="0">{
        return p.value
}</span>

func isStrongPassword(v string) bool <span class="cov0" title="0">{
        hasLower := regexp.MustCompile(`[a-z]`).MatchString(v)
        hasUpper := regexp.MustCompile(`[A-Z]`).MatchString(v)
        hasDigit := regexp.MustCompile(`[0-9]`).MatchString(v)
        hasSpecial := regexp.MustCompile(`[!@#$%^&amp;*()_\-+=&lt;&gt;?]`).MatchString(v)

        return hasLower &amp;&amp; hasUpper &amp;&amp; hasDigit &amp;&amp; hasSpecial
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package valueobjects

import (
        "errors"
        "log"
        "unicode"
)

type Phone struct {
        value *string
}

func NewPhone(v *string) (*Phone, error) <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span> else<span class="cov0" title="0"> if !isNumeric(*v) </span><span class="cov0" title="0">{
                log.Printf("[valueobject:phone] phone value isn't entirely numeric")
                return &amp;Phone{}, errors.New("invalid phone value")
        }</span> else<span class="cov0" title="0"> if len(*v) &gt; 10 </span><span class="cov0" title="0">{
                log.Printf("[valueobject:phone] phone value too long")
                return &amp;Phone{}, errors.New("phone number too long: maximum length is 10")
        }</span>
        <span class="cov0" title="0">return &amp;Phone{value: v}, nil</span>
}

func (p Phone) String() *string <span class="cov0" title="0">{
        if p.value == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return p.value</span>
}

func isNumeric(str string) bool <span class="cov0" title="0">{
        for _, r := range str </span><span class="cov0" title="0">{
                if !unicode.IsDigit(r) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package handlers

import "github.com/carlosclavijo/Nutricenter-Contracting/internal/domain/administrator"

type AdministratorHandler struct {
        repository administrators.AdministratorRepository
        factory    administrators.AdministratorFactory
}

func NewAdministratorHandler(r administrators.AdministratorRepository, f administrators.AdministratorFactory) *AdministratorHandler <span class="cov0" title="0">{
        return &amp;AdministratorHandler{
                repository: r,
                factory:    f,
        }
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">package handlers

import (
        "context"
        "github.com/carlosclavijo/Nutricenter-Contracting/internal/application/administrator/queries"
        "log"
)

func (h *AdministratorHandler) HandleCountActive(ctx context.Context, query queries.CountActiveAdministratorsQuery) (int, error) <span class="cov0" title="0">{
        count, err := h.repository.CountActive(ctx)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[handler:administrator][HandleCountActive] error counting active administrators: %v", err)
                return 0, err
        }</span>
        <span class="cov0" title="0">return count, nil</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package handlers

import (
        "context"
        "github.com/carlosclavijo/Nutricenter-Contracting/internal/application/administrator/queries"
        "log"
)

func (h *AdministratorHandler) HandleCountAll(ctx context.Context, qry queries.CountAllAdministratorsQuery) (int, error) <span class="cov0" title="0">{
        count, err := h.repository.CountAll(ctx)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[handler:administrator][HandleCountAll] error counting all administrators: %v", err)
                return 0, err
        }</span>
        <span class="cov0" title="0">return count, nil</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package handlers

import (
        "context"
        "github.com/carlosclavijo/Nutricenter-Contracting/internal/application/administrator/queries"
        "log"
)

func (h *AdministratorHandler) HandleCountDeleted(ctx context.Context, qry queries.CountDeletedAdministratorsQuery) (int, error) <span class="cov0" title="0">{
        count, err := h.repository.CountDeleted(ctx)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[handler:administrator][HandleCountDeleted] error counting deleted administrators: %v", err)
                return 0, err
        }</span>
        <span class="cov0" title="0">return count, nil</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package handlers

import (
        "context"
        "github.com/carlosclavijo/Nutricenter-Contracting/internal/application/administrator/queries"
        "log"
)

func (h *AdministratorHandler) HandleExistByEmail(ctx context.Context, qry queries.ExistAdministratorByEmailQuery) (bool, error) <span class="cov0" title="0">{
        exist, err := h.repository.ExistByEmail(ctx, qry.Email)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[handler:administrator][HandleExistByEmail] error proving if an administrator exist: %v", err)
                return false, err
        }</span>
        <span class="cov0" title="0">return exist, err</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package handlers

import (
        "context"
        "github.com/carlosclavijo/Nutricenter-Contracting/internal/application/administrator/queries"
        "log"
)

func (h *AdministratorHandler) HandleExistById(ctx context.Context, qry queries.ExistAdministratorByIdQuery) (bool, error) <span class="cov0" title="0">{
        exist, err := h.repository.ExistById(ctx, qry.Id)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[handler:administrator][HandleExistById] error proving if an administrator exist: %v", err)
                return false, err
        }</span>
        <span class="cov0" title="0">return exist, nil</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package handlers

import (
        "context"
        "github.com/carlosclavijo/Nutricenter-Contracting/internal/application/administrator/queries"
        "github.com/carlosclavijo/Nutricenter-Contracting/internal/domain/administrator"
        "log"
)

func (h *AdministratorHandler) HandleGetByEmail(ctx context.Context, qry queries.GetAdministratorByEmailQuery) (*administrators.Administrator, error) <span class="cov0" title="0">{
        administrator, err := h.repository.GetByEmail(ctx, qry.Email)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[handler:administrator][HandlerGetByEmail] error getting administrator by its email: %v", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">return administrator, err</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package handlers

import (
        "context"
        "github.com/carlosclavijo/Nutricenter-Contracting/internal/application/administrator/dto"
        "github.com/carlosclavijo/Nutricenter-Contracting/internal/application/administrator/queries"
        "log"
)

func (h *AdministratorHandler) HandleGetById(ctx context.Context, qry queries.GetAdministratorByIdQuery) (*dto.AdministratorDTO, error) <span class="cov0" title="0">{
        administrators, err := h.repository.GetById(ctx, qry.Id)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[handler:administrator][HandleGetById] error getting administrator by its id: %v", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">return administrators, nil</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package handlers

import (
        "context"
        "github.com/carlosclavijo/Nutricenter-Contracting/internal/application/administrator/dto"
        "github.com/carlosclavijo/Nutricenter-Contracting/internal/application/administrator/queries"
        "log"
)

func (h *AdministratorHandler) HandleGetAll(ctx context.Context, qry queries.GetAllAdministratorsQuery) (*[]dto.AdministratorDTO, error) <span class="cov0" title="0">{
        administrators, err := h.repository.GetAll(ctx)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[handler:administrator][HandleGetAll] error getting all administrators: %v", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">return administrators, nil</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package handlers

import (
        "context"
        "github.com/carlosclavijo/Nutricenter-Contracting/internal/application/administrator/dto"
        "github.com/carlosclavijo/Nutricenter-Contracting/internal/application/administrator/queries"
        "log"
)

func (h *AdministratorHandler) HandleGetList(ctx context.Context, qry queries.GetListAdministratorsQuery) (*[]dto.AdministratorDTO, error) <span class="cov0" title="0">{
        administrators, err := h.repository.GetList(ctx)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[handler:administrator][HandleGetList] error getting administrators list: %v", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">return administrators, nil</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package handlers

import (
        "context"
        "github.com/carlosclavijo/Nutricenter-Contracting/internal/application/patient/queries"
        "log"
)

func (h *PatientHandler) HandleCountActive(ctx context.Context, qry queries.CountActivePatientsQuery) (int, error) <span class="cov0" title="0">{
        count, err := h.repository.CountActive(ctx)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[handler:patient][HandleCountActive] error counting active patients: %v", err)
                return 0, err
        }</span>
        <span class="cov0" title="0">return count, nil</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package handlers

import (
        "context"
        "github.com/carlosclavijo/Nutricenter-Contracting/internal/application/patient/queries"
        "log"
)

func (h *PatientHandler) HandleCountAll(ctx context.Context, qry queries.CountAllPatientsQuery) (int, error) <span class="cov0" title="0">{
        count, err := h.repository.CountAll(ctx)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[handler:patient][HandleCountAll] error counting all patients: %v", err)
                return 0, err
        }</span>
        <span class="cov0" title="0">return count, nil</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package handlers

import (
        "context"
        "github.com/carlosclavijo/Nutricenter-Contracting/internal/application/patient/queries"
        "log"
)

func (h *PatientHandler) HandleCountDeleted(ctx context.Context, qry queries.CountDeletedPatientsQuery) (int, error) <span class="cov0" title="0">{
        count, err := h.repository.CountDeleted(ctx)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[handler:patient][HandleCountDeleted] error counting deleted patients: %v", err)
                return 0, err
        }</span>
        <span class="cov0" title="0">return count, nil</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package handlers

import (
        "context"
        "github.com/carlosclavijo/Nutricenter-Contracting/internal/application/patient/queries"
        "log"
)

func (h *PatientHandler) HandleExistByEmail(ctx context.Context, qry queries.ExistPatientByEmailQuery) (bool, error) <span class="cov0" title="0">{
        exist, err := h.repository.ExistByEmail(ctx, qry.Email)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[handler:patient][HandleExistByEmail] error proving if an patient exist: %v", err)
                return false, err
        }</span>
        <span class="cov0" title="0">return exist, err</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package handlers

import (
        "context"
        "github.com/carlosclavijo/Nutricenter-Contracting/internal/application/patient/queries"
        "log"
)

func (h *PatientHandler) HandleExistById(ctx context.Context, qry queries.ExistPatientByIdQuery) (bool, error) <span class="cov0" title="0">{
        exist, err := h.repository.ExistById(ctx, qry.Id)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[handler:patient][HandleExistById] error proving if an patient exist: %v", err)
                return false, err
        }</span>
        <span class="cov0" title="0">return exist, nil</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package handlers

import (
        "context"
        "github.com/carlosclavijo/Nutricenter-Contracting/internal/application/patient/dto"
        "github.com/carlosclavijo/Nutricenter-Contracting/internal/application/patient/queries"
        "log"
)

func (h *PatientHandler) HandleGetAll(ctx context.Context, qry queries.GetAllPatientsQuery) (*[]dto.PatientDTO, error) <span class="cov0" title="0">{
        patients, err := h.repository.GetAll(ctx)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[handler:patient][HandleGetAll] error getting all patients: %v", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">return patients, nil</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package handlers

import (
        "context"
        "github.com/carlosclavijo/Nutricenter-Contracting/internal/application/patient/dto"
        "github.com/carlosclavijo/Nutricenter-Contracting/internal/application/patient/queries"
        "log"
)

func (h *PatientHandler) HandleGetList(ctx context.Context, qry queries.GetListPatientsQuery) (*[]dto.PatientDTO, error) <span class="cov0" title="0">{
        patients, err := h.repository.GetList(ctx)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[handler:[patient]][HandleGetList] error getting patients list: %v", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">return patients, nil</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package handlers

import (
        "context"
        "github.com/carlosclavijo/Nutricenter-Contracting/internal/application/patient/queries"
        "github.com/carlosclavijo/Nutricenter-Contracting/internal/domain/patient"
        "log"
)

func (h *PatientHandler) HandleGetByEmail(ctx context.Context, qry queries.GetPatientByEmailQuery) (*patients.Patient, error) <span class="cov0" title="0">{
        patient, err := h.repository.GetByEmail(ctx, qry.Email)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[handler:patient][HandlerGetByEmail] error getting patient by its email: %v", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">return patient, err</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package handlers

import (
        "context"
        "github.com/carlosclavijo/Nutricenter-Contracting/internal/application/patient/dto"
        "github.com/carlosclavijo/Nutricenter-Contracting/internal/application/patient/queries"
        "log"
)

func (h *PatientHandler) HandleGetById(ctx context.Context, qry queries.GetPatientByIdQuery) (*dto.PatientDTO, error) <span class="cov0" title="0">{
        patients, err := h.repository.GetById(ctx, qry.Id)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[handler:patient][HandleGetById] error getting patient by its id: %v", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">return patients, nil</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package handlers

import (
        patients "github.com/carlosclavijo/Nutricenter-Contracting/internal/domain/patient"
)

type PatientHandler struct {
        repository patients.PatientRepository
        factory    patients.PatientFactory
}

func NewPatientHandler(r patients.PatientRepository, f patients.PatientFactory) *PatientHandler <span class="cov0" title="0">{
        return &amp;PatientHandler{
                repository: r,
                factory:    f,
        }
}</span>
</pre>
		
		<pre class="file" id="file51" style="display: none">package persistence

import (
        "database/sql"
        "fmt"
        _ "github.com/lib/pq"
        "log"
        "os"
)

func NewPostgresDB() (*sql.DB, error) <span class="cov0" title="0">{
        dsn := fmt.Sprintf(
                "user=%s password=%s dbname=%s host=%s port=%s sslmode=disable",
                os.Getenv("DB_USER"),
                os.Getenv("DB_PASSWORD"),
                os.Getenv("DB_NAME"),
                os.Getenv("DB_HOST"),
                os.Getenv("DB_PORT"),
        )
        log.Print("DSN:", dsn)

        db, err := sql.Open("postgres", dsn)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[infrastructure:database] Connecting to PostgreDB: %v", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">if err = db.Ping(); err != nil </span><span class="cov0" title="0">{
                log.Printf("[infrastructure:database] database connection established but ping failed: %v", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">return db, nil</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">package repositories

import (
        "context"
        "database/sql"
        "fmt"
        "github.com/carlosclavijo/Nutricenter-Contracting/internal/application/administrator/dto"
        "github.com/carlosclavijo/Nutricenter-Contracting/internal/domain/administrator"
        "github.com/google/uuid"
        "log"
        "time"
)

type AdministratorRepository struct {
        Db *sql.DB
}

func (r *AdministratorRepository) GetAll(ctx context.Context) (*[]dto.AdministratorDTO, error) <span class="cov0" title="0">{
        var admins []dto.AdministratorDTO

        query := `
                SELECT id, first_name, last_name, email, gender, birth, phone
                FROM administrator
        `
        rows, err := r.Db.QueryContext(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[repository:administrator][GetAll] error executing SQL query '%s': %v", query, err)
                return nil, fmt.Errorf("query failed: %w", err)
        }</span>

        <span class="cov0" title="0">defer func(rows *sql.Rows) </span><span class="cov0" title="0">{
                if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                        log.Printf("[repository:administrator][GetAll] failed to close rows: %v", err)
                }</span>
        }(rows)
        <span class="cov0" title="0">for rows.Next() </span><span class="cov0" title="0">{
                var admin dto.AdministratorDTO
                err := rows.Scan(
                        &amp;admin.Id, &amp;admin.FirstName, &amp;admin.LastName, &amp;admin.Email, &amp;admin.Gender, &amp;admin.Birth, &amp;admin.Phone,
                )
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("[repository:administrator][GetAll] error reading adminDTO for a slice of admins: %v", err)
                        return nil, fmt.Errorf("scan failed: %w", err)
                }</span>
                <span class="cov0" title="0">admins = append(admins, admin)</span>
        }

        <span class="cov0" title="0">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                log.Printf("[repository:administrator][GetAll] error reading admins: %v", err)
                return nil, fmt.Errorf("rows iteration error: %w", err)
        }</span>
        <span class="cov0" title="0">log.Printf("[repository:administrator][GetAll] successfully fetched %d administrators", len(admins))
        return &amp;admins, nil</span>
}

func (r *AdministratorRepository) GetList(ctx context.Context) (*[]dto.AdministratorDTO, error) <span class="cov0" title="0">{
        var admins []dto.AdministratorDTO

        query := `
                SELECT id, first_name, last_name, email, gender, birth, phone
                FROM administrator
                WHERE deleted_at IS NULL
        `
        rows, err := r.Db.QueryContext(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[repository:administrator][GetList] error executing SQL query '%s': %v", query, err)
                return nil, fmt.Errorf("query failed: %w", err)
        }</span>

        <span class="cov0" title="0">defer func(rows *sql.Rows) </span><span class="cov0" title="0">{
                err := rows.Close()
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("[repository:administrator][GetList] failed to close rows: %v", err)
                }</span>
        }(rows)

        <span class="cov0" title="0">for rows.Next() </span><span class="cov0" title="0">{
                var admin dto.AdministratorDTO

                err := rows.Scan(
                        &amp;admin.Id, &amp;admin.FirstName, &amp;admin.LastName, &amp;admin.Email, &amp;admin.Gender, &amp;admin.Birth, &amp;admin.Phone,
                )
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("[repository:administrator][GetList] error reading adminDTO for a slice of admins: %v", err)
                        return nil, fmt.Errorf("scan failed: %w", err)
                }</span>
                <span class="cov0" title="0">admins = append(admins, admin)</span>
        }

        <span class="cov0" title="0">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                log.Printf("[repository:administrator][GetList] error Reading admins: %v", err)
                return nil, fmt.Errorf("rows iteration error: %w", err)
        }</span>

        <span class="cov0" title="0">log.Printf("[repository:administrator][GetList] successfully fetched %d administrators", len(admins))
        return &amp;admins, nil</span>
}

func (r *AdministratorRepository) GetById(ctx context.Context, id uuid.UUID) (*dto.AdministratorDTO, error) <span class="cov0" title="0">{
        var admin dto.AdministratorDTO

        query := `
                SELECT id, first_name, last_name, email, gender, birth, phone
                FROM administrator
                WHERE id = $1
        `
        err := r.Db.QueryRowContext(ctx, query, id).Scan(
                &amp;admin.Id, &amp;admin.FirstName, &amp;admin.LastName, &amp;admin.Email, &amp;admin.Gender, &amp;admin.Birth, &amp;admin.Phone,
        )

        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[repository:administrator][GetById] error executing SQL query '%s': %v", query, err)
                return nil, fmt.Errorf("query failed: %w", err)
        }</span>

        <span class="cov0" title="0">log.Printf("[repository:administrator][GetById] successfully fetched administrator")
        return &amp;admin, nil</span>
}

func (r *AdministratorRepository) GetByEmail(ctx context.Context, email string) (*administrators.Administrator, error) <span class="cov0" title="0">{
        var (
                id                                              uuid.UUID
                firstName, lastName, emailStr, password, gender string
                lastLoginAt, createdAt, updatedAt               time.Time
                birth, deletedAt                                *time.Time
                phone                                           *string
        )

        query := `
                SELECT id, first_name, last_name, email, password, gender, birth, phone, last_login_at, created_at, updated_at, deleted_at
                FROM administrator
                WHERE email = $1
        `

        err := r.Db.QueryRowContext(ctx, query, email).Scan(
                &amp;id, &amp;firstName, &amp;lastName, &amp;emailStr, &amp;password, &amp;gender, &amp;birth, &amp;phone, &amp;lastLoginAt, &amp;createdAt, &amp;updatedAt, &amp;deletedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[repository:administrator][GetByEmail] error executing SQL query '%s'\nfailed to fetch administrator: %v", query, err)
                return nil, fmt.Errorf("query failed: %w", err)
        }</span>

        <span class="cov0" title="0">admin := administrators.NewAdministratorFromDB(id, firstName, lastName, emailStr, password, gender, birth, phone, lastLoginAt, createdAt, updatedAt, deletedAt)
        log.Printf("[repository:administrator][GetByEmail] successfully fetched administrator")
        return admin, nil</span>
}

func (r *AdministratorRepository) ExistById(ctx context.Context, id uuid.UUID) (bool, error) <span class="cov0" title="0">{
        var exist bool

        query := `
                SELECT EXISTS(
                        SELECT 1 
                        FROM administrator
                        WHERE id = $1 
                                AND deleted_at IS NULL)
        `
        err := r.Db.QueryRowContext(ctx, query, id).Scan(
                &amp;exist,
        )
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[repository:administrator][ExistById] error executing SQL query '%s': %v", query, err)
                return false, err
        }</span>

        <span class="cov0" title="0">log.Printf("[repository:administrator][ExistsById] id=%s exists=%t", id, exist)
        return exist, nil</span>
}

func (r *AdministratorRepository) ExistByEmail(ctx context.Context, email string) (bool, error) <span class="cov0" title="0">{
        var exist bool

        query := `
                SELECT EXISTS(
                        SELECT 1 
                        FROM administrator
                        WHERE email = $1 
                                AND deleted_at IS NULL)
        `
        err := r.Db.QueryRowContext(ctx, query, email).Scan(
                &amp;exist,
        )
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[repository:administrator][ExistByEmail] error executing SQL query '%s': %v", query, err)
                return false, err
        }</span>

        <span class="cov0" title="0">log.Printf("[repository:administrator][ExistByEmail] email=%s exists=%t", email, exist)
        return exist, nil</span>
}

func (r *AdministratorRepository) Create(ctx context.Context, adm *administrators.Administrator) (*administrators.Administrator, error) <span class="cov0" title="0">{
        var (
                id                                 uuid.UUID
                firstName, lastName, email, gender string
                lastLoginAt, createdAt, updatedAt  time.Time
                birth, birthVal, deletedAt         *time.Time
                phone, phoneVal                    *string
        )

        if adm.Birth() != nil </span><span class="cov0" title="0">{
                birthVal = adm.Birth().Value()
        }</span>
        <span class="cov0" title="0">if adm.Phone() != nil </span><span class="cov0" title="0">{
                s := adm.Phone().String()
                phoneVal = s
        }</span>

        <span class="cov0" title="0">query := `
                INSERT INTO administrator(id, first_name, last_name, email, password, gender, birth, phone)
                VALUES($1, $2, $3, $4, $5, $6, $7, $8)
                RETURNING id, first_name, last_name, email, gender, birth, phone, last_login_at, created_at, updated_at, deleted_at
        `
        err := r.Db.QueryRowContext(
                ctx, query, adm.Id(), adm.FirstName(), adm.LastName(), adm.Email().Value(), adm.Password().String(), adm.Gender(), birthVal, phoneVal).Scan(
                &amp;id, &amp;firstName, &amp;lastName, &amp;email, &amp;gender, &amp;birth, &amp;phone, &amp;lastLoginAt, &amp;createdAt, &amp;updatedAt, &amp;deletedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[repository:administrator][Create] error executing SQL query '%s': %v", query, err)
                return nil, fmt.Errorf("scan failed: %w", err)
        }</span>

        <span class="cov0" title="0">admin := administrators.NewAdministratorFromDB(id, firstName, lastName, email, "", gender, birth, phone, lastLoginAt, createdAt, updatedAt, deletedAt)
        log.Printf("[repository:administrator][Create] successfully created administrator in DB %v", admin)
        return admin, nil</span>
}

func (r *AdministratorRepository) Update(ctx context.Context, adm *administrators.Administrator) (*administrators.Administrator, error) <span class="cov0" title="0">{
        var (
                id                                 uuid.UUID
                firstName, lastName, email, gender string
                phone                              *string
                lastLoginAt, createdAt, updatedAt  time.Time
                birth, deletedAt                   *time.Time
        )

        if adm.Birth() != nil </span><span class="cov0" title="0">{
                birth = adm.Birth().Value()
        }</span>

        <span class="cov0" title="0">if adm.Phone() != nil </span><span class="cov0" title="0">{
                phone = adm.Phone().String()
        }</span>

        <span class="cov0" title="0">query := `
        UPDATE administrator
        SET first_name = $1, last_name = $2, email = $3, password = $4, gender = $5, birth = $6, phone = $7, last_login_at = $8, updated_at = $9 
        WHERE id = $10
        RETURNING id, first_name, last_name, email, gender, birth, phone, last_login_at, created_at, updated_at, deleted_at
    `

        err := r.Db.QueryRowContext(
                ctx,
                query,
                adm.FirstName(),
                adm.LastName(),
                adm.Email().Value(),
                adm.Password().String(),
                adm.Gender(),
                birth,
                phone,
                adm.LastLoginAt,
                adm.UpdatedAt,
                adm.Id(),
        ).Scan(
                &amp;id, &amp;firstName, &amp;lastName, &amp;email, &amp;gender, &amp;birth, &amp;phone, &amp;lastLoginAt, &amp;createdAt, &amp;updatedAt, &amp;deletedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[repository:administrator][Update] error executing SQL query: %v", err)
                return nil, fmt.Errorf("scan failed: %w", err)
        }</span>

        <span class="cov0" title="0">updatedAdmin := administrators.NewAdministratorFromDB(
                id, firstName, lastName, email, adm.Password().String(), gender, birth, phone, lastLoginAt, createdAt, updatedAt, deletedAt,
        )

        return updatedAdmin, nil</span>
}

func (r *AdministratorRepository) Delete(ctx context.Context, id uuid.UUID) (*administrators.Administrator, error) <span class="cov0" title="0">{
        var (
                idNew                              uuid.UUID
                firstName, lastName, email, gender string
                lastLoginAt, createdAt, updatedAt  time.Time
                birth, deletedAt                   *time.Time
                phone                              *string
        )

        query := `
                UPDATE administrator
                SET deleted_at = NOW() 
                WHERE id = $1 
                RETURNING id, first_name, last_name, email, gender, birth, phone, last_login_at, created_at, updated_at, deleted_at
        `
        err := r.Db.QueryRowContext(ctx, query, id).Scan(
                &amp;idNew, &amp;firstName, &amp;lastName, &amp;email, &amp;gender, &amp;birth, &amp;phone, &amp;lastLoginAt, &amp;createdAt, &amp;updatedAt, &amp;deletedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[repository:administrator][Delete] error executing SQL query '%s': %v", query, err)
                return nil, err
        }</span>

        <span class="cov0" title="0">admin := administrators.NewAdministratorFromDB(id, firstName, lastName, email, "", gender, birth, phone, lastLoginAt, createdAt, updatedAt, deletedAt)
        log.Printf("[repository:administrator][Delete] successfully soft deleted administrator %v", admin)
        return admin, nil</span>
}

func (r *AdministratorRepository) Restore(ctx context.Context, id uuid.UUID) (*administrators.Administrator, error) <span class="cov0" title="0">{
        var (
                idNew                              uuid.UUID
                firstName, lastName, email, gender string
                lastLoginAt, createdAt, updatedAt  time.Time
                birth, deletedAt                   *time.Time
                phone                              *string
        )

        query := `
                UPDATE administrator
                SET deleted_at = NULL
                WHERE id = $1
                RETURNING id, first_name, last_name, email, gender, birth, phone, last_login_at, created_at, updated_at, deleted_at
        `
        err := r.Db.QueryRowContext(ctx, query, id).Scan(
                &amp;idNew, &amp;firstName, &amp;lastName, &amp;email, &amp;gender, &amp;birth, &amp;phone, &amp;lastLoginAt, &amp;createdAt, &amp;updatedAt, &amp;deletedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[repository:administrator][Restore] error executing SQL query '%s': %v", query, err)
                return nil, err
        }</span>

        <span class="cov0" title="0">admin := administrators.NewAdministratorFromDB(id, firstName, lastName, email, "", gender, birth, phone, lastLoginAt, createdAt, updatedAt, deletedAt)
        log.Printf("[repository:administrator][Delete] successfully restore administrator %v", admin)
        return admin, nil</span>
}

func (r *AdministratorRepository) CountAll(ctx context.Context) (int, error) <span class="cov0" title="0">{
        var count int
        query := `
                SELECT COUNT(*)
                FROM administrator
        `
        err := r.Db.QueryRowContext(ctx, query).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[repository:administrator][CountAll] error executing SQL query in CountAll: %v", err)
                return 0, err
        }</span>
        <span class="cov0" title="0">return count, nil</span>
}

func (r *AdministratorRepository) CountActive(ctx context.Context) (int, error) <span class="cov0" title="0">{
        var count int
        query := `SELECT COUNT(*)
                FROM administrator 
                WHERE deleted_at IS NULL
        `
        err := r.Db.QueryRowContext(ctx, query).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[repository:administrator][CountActive] error executing SQL query in CountActive: %v", err)
                return 0, err
        }</span>
        <span class="cov0" title="0">return count, nil</span>
}

func (r *AdministratorRepository) CountDeleted(ctx context.Context) (int, error) <span class="cov0" title="0">{
        var count int
        query := `SELECT COUNT(*)
                FROM administrator
                WHERE deleted_at IS NOT NULL
        `
        err := r.Db.QueryRowContext(ctx, query).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[repository:administrator][CountDeleted] error executing SQL query in CountDeleted: %v", err)
                return 0, err
        }</span>
        <span class="cov0" title="0">return count, nil</span>
}

func NewAdministratorRepository(db *sql.DB) administrators.AdministratorRepository <span class="cov0" title="0">{
        return &amp;AdministratorRepository{Db: db}
}</span>
</pre>
		
		<pre class="file" id="file53" style="display: none">package repositories

import (
        "context"
        "database/sql"
        "github.com/carlosclavijo/Nutricenter-Contracting/internal/application/contract/dto"
        "github.com/carlosclavijo/Nutricenter-Contracting/internal/domain/contract"
        "github.com/google/uuid"
)

type ContractRepository struct {
        DB *sql.DB
}

func (r *ContractRepository) GetList(ctx context.Context) (*[]dto.ContractDTO, error) <span class="cov0" title="0">{
        //TODO implement me
        panic("implement me")</span>
}

func (r *ContractRepository) GetById(ctx context.Context, id uuid.UUID) (*dto.ContractDTO, error) <span class="cov0" title="0">{
        //TODO implement me
        panic("implement me")</span>
}

func (r *ContractRepository) Create(ctx context.Context, c *contracts.Contract) (*contracts.Contract, error) <span class="cov0" title="0">{
        /*var (
                id, administratorId, patientId, dId uuid.UUID
                contractType                                          contracts.ContractType
                contractStatus                                        contracts.ContractStatus
                creation, start, end, createdAt, updatedAt, deletedAt time.Time
                cost                                                  int
                //deliveries                                            []deliveries.Delivery
        )

        query := `
                INSERT INTO contract(id, administrator_id, patient_id, contract_type, start_date, end_date, cost_value)
                VALUES($1, $2, $3, $4, $5, $6, $7)
                RETURNING *
        `

        err := r.DB.QueryRowContext(
                ctx, query, c.Id(), c.AdministratorId(), c.PatientId(), string(c.ContractType()), c.StartDate(), c.EndDate(), c.CostValue()).Scan(
                &amp;id, &amp;administratorId, &amp;patientId, &amp;contractType, &amp;contractStatus, &amp;creation, &amp;start, &amp;end, &amp;cost, &amp;createdAt, &amp;updatedAt, &amp;deletedAt,
        )

        if err != nil {
                log.Printf("[repository:contract][Create] error executing SQL query '%s': '%v", query, err)
                return nil, fmt.Errorf("scan failed: %w", err)
        }

        query = `
                INSERT INTO delivery(id, contract_id, date, street, number)
                VALUES($1, $2, $3, $4, $5)
                RETURNING *
        `

        for k, v := range c.Deliveries() {

        }

        contract := contracts.NewContractFromDb(id, administratorId, patientId, contractType, contractStatus, creation, start, &amp;end, cost, createdAt, updatedAt, &amp;deletedAt)
        log.Printf("[repository:contract][Create] successfully created contract %v", contract)
        return contract, nil*/
        //TODO implement me
        panic("implement me")</span>
}

func (r *ContractRepository) Update(ctx context.Context, contract *contracts.Contract) (*contracts.Contract, error) <span class="cov0" title="0">{
        //TODO implement me
        panic("implement me")</span>
}

func (r *ContractRepository) Delete(ctx context.Context, id uuid.UUID) (*contracts.Contract, error) <span class="cov0" title="0">{
        //TODO implement me
        panic("implement me")</span>
}

func (r *ContractRepository) Restore(ctx context.Context, id uuid.UUID) (*contracts.Contract, error) <span class="cov0" title="0">{
        //TODO implement me
        panic("implement me")</span>
}

func NewContractRepository(db *sql.DB) contracts.ContractRepository <span class="cov0" title="0">{
        return &amp;ContractRepository{DB: db}
}</span>
</pre>
		
		<pre class="file" id="file54" style="display: none">package repositories

import (
        "context"
        "database/sql"
        "fmt"
        "github.com/carlosclavijo/Nutricenter-Contracting/internal/application/patient/dto"
        patients "github.com/carlosclavijo/Nutricenter-Contracting/internal/domain/patient"
        "github.com/google/uuid"
        "log"
        "time"
)

type PatientRepository struct {
        Db *sql.DB
}

func (r *PatientRepository) GetAll(ctx context.Context) (*[]dto.PatientDTO, error) <span class="cov0" title="0">{
        var patns []dto.PatientDTO

        query := `
                SELECT id, first_name, last_name, email, gender, birth, phone
                FROM patient
        `
        rows, err := r.Db.QueryContext(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[repository:patient][GetAll] error executing SQL query '%s': %v", query, err)
                return nil, fmt.Errorf("query failed: %w", err)
        }</span>

        <span class="cov0" title="0">defer func(rows *sql.Rows) </span><span class="cov0" title="0">{
                if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                        log.Printf("[repository:patient][GetAll] failed to close rows: %v", err)
                }</span>
        }(rows)
        <span class="cov0" title="0">for rows.Next() </span><span class="cov0" title="0">{
                var patient dto.PatientDTO
                err := rows.Scan(
                        &amp;patient.Id, &amp;patient.FirstName, &amp;patient.LastName, &amp;patient.Email, &amp;patient.Gender, &amp;patient.Birth, &amp;patient.Phone,
                )
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("[repository:patient][GetAll] error reading patientDTO for a slice of patients: %v", err)
                        return nil, fmt.Errorf("scan failed: %w", err)
                }</span>
                <span class="cov0" title="0">patns = append(patns, patient)</span>
        }

        <span class="cov0" title="0">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                log.Printf("[repository:patient][GetAll] error reading patients: %v", err)
                return nil, fmt.Errorf("rows iteration error: %w", err)
        }</span>
        <span class="cov0" title="0">log.Printf("[repository:patient][GetAll] successfully fetched %d patients", len(patns))
        return &amp;patns, nil</span>
}

func (r *PatientRepository) GetList(ctx context.Context) (*[]dto.PatientDTO, error) <span class="cov0" title="0">{
        var patns []dto.PatientDTO

        query := `
                SELECT id, first_name, last_name, email, gender, birth, phone
                FROM patient
                WHERE deleted_at IS NULL
        `
        rows, err := r.Db.QueryContext(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[repository:patient][GetList] error executing SQL query '%s': %v", query, err)
                return nil, fmt.Errorf("query failed: %w", err)
        }</span>

        <span class="cov0" title="0">defer func(rows *sql.Rows) </span><span class="cov0" title="0">{
                err := rows.Close()
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("[repository:patient][GetList] failed to close rows: %v", err)
                }</span>
        }(rows)

        <span class="cov0" title="0">for rows.Next() </span><span class="cov0" title="0">{
                var patient dto.PatientDTO

                err := rows.Scan(
                        &amp;patient.Id, &amp;patient.FirstName, &amp;patient.LastName, &amp;patient.Email, &amp;patient.Gender, &amp;patient.Birth, &amp;patient.Phone,
                )
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("[repository:patient][GetList] error reading patientDTO for a slice of patients: %v", err)
                        return nil, fmt.Errorf("scan failed: %w", err)
                }</span>
                <span class="cov0" title="0">patns = append(patns, patient)</span>
        }

        <span class="cov0" title="0">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                log.Printf("[repository:patient][GetList] error Reading patients: %v", err)
                return nil, fmt.Errorf("rows iteration error: %w", err)
        }</span>

        <span class="cov0" title="0">log.Printf("[repository:patient][GetList] successfully fetched %d patients", len(patns))
        return &amp;patns, nil</span>
}

func (r *PatientRepository) GetById(ctx context.Context, id uuid.UUID) (*dto.PatientDTO, error) <span class="cov0" title="0">{
        var patient dto.PatientDTO

        query := `
                SELECT id, first_name, last_name, email, gender, birth, phone
                FROM patient
                WHERE id = $1
        `
        err := r.Db.QueryRowContext(ctx, query, id).Scan(
                &amp;patient.Id, &amp;patient.FirstName, &amp;patient.LastName, &amp;patient.Email, &amp;patient.Gender, &amp;patient.Birth, &amp;patient.Phone,
        )

        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[repository:patient][GetById] error executing SQL query '%s': %v", query, err)
                return nil, fmt.Errorf("query failed: %w", err)
        }</span>

        <span class="cov0" title="0">log.Printf("[repository:patient][GetById] successfully fetched patient")
        return &amp;patient, nil</span>
}

func (r *PatientRepository) GetByEmail(ctx context.Context, email string) (*patients.Patient, error) <span class="cov0" title="0">{
        var (
                id                                              uuid.UUID
                firstName, lastName, emailStr, password, gender string
                lastLoginAt, createdAt, updatedAt               time.Time
                birth, deletedAt                                *time.Time
                phone                                           *string
        )

        query := `
                SELECT id, first_name, last_name, email, password, gender, birth, phone, last_login_at, created_at, updated_at, deleted_at
                FROM patient
                WHERE email = $1
        `

        err := r.Db.QueryRowContext(ctx, query, email).Scan(
                &amp;id, &amp;firstName, &amp;lastName, &amp;emailStr, &amp;password, &amp;gender, &amp;birth, &amp;phone, &amp;lastLoginAt, &amp;createdAt, &amp;updatedAt, &amp;deletedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[repository:patient][GetByEmail] error executing SQL query '%s'\nfailed to fetch patient: %v", query, err)
                return nil, fmt.Errorf("query failed: %w", err)
        }</span>

        <span class="cov0" title="0">patient := patients.NewPatientFromDB(id, firstName, lastName, emailStr, password, gender, birth, phone, lastLoginAt, createdAt, updatedAt, deletedAt)
        log.Printf("[repository:patient][GetByEmail] successfully fetched patient")
        return patient, nil</span>
}

func (r *PatientRepository) ExistById(ctx context.Context, id uuid.UUID) (bool, error) <span class="cov0" title="0">{
        var exist bool

        query := `
                SELECT EXISTS(
                        SELECT 1 
                        FROM patient
                        WHERE id = $1 
                                AND deleted_at IS NULL)
        `
        err := r.Db.QueryRowContext(ctx, query, id).Scan(
                &amp;exist,
        )
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[repository:patient][ExistById] error executing SQL query '%s': %v", query, err)
                return false, err
        }</span>

        <span class="cov0" title="0">log.Printf("[repository:patient][ExistsById] id=%s exists=%t", id, exist)
        return exist, nil</span>
}

func (r *PatientRepository) ExistByEmail(ctx context.Context, email string) (bool, error) <span class="cov0" title="0">{
        var exist bool

        query := `
                SELECT EXISTS(
                        SELECT 1 
                        FROM patient
                        WHERE email = $1 
                                AND deleted_at IS NULL)
        `
        err := r.Db.QueryRowContext(ctx, query, email).Scan(
                &amp;exist,
        )
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[repository:patient][ExistByEmail] error executing SQL query '%s': %v", query, err)
                return false, err
        }</span>

        <span class="cov0" title="0">log.Printf("[repository:patient][ExistByEmail] email=%s exists=%t", email, exist)
        return exist, nil</span>
}

func (r *PatientRepository) Create(ctx context.Context, adm *patients.Patient) (*patients.Patient, error) <span class="cov0" title="0">{
        var (
                id                                 uuid.UUID
                firstName, lastName, email, gender string
                lastLoginAt, createdAt, updatedAt  time.Time
                birth, birthVal, deletedAt         *time.Time
                phone, phoneVal                    *string
        )

        if adm.Birth() != nil </span><span class="cov0" title="0">{
                birthVal = adm.Birth().Value()
        }</span>
        <span class="cov0" title="0">if adm.Phone() != nil </span><span class="cov0" title="0">{
                s := adm.Phone().String()
                phoneVal = s
        }</span>

        <span class="cov0" title="0">query := `
                INSERT INTO patient(id, first_name, last_name, email, password, gender, birth, phone)
                VALUES($1, $2, $3, $4, $5, $6, $7, $8)
                RETURNING id, first_name, last_name, email, gender, birth, phone, last_login_at, created_at, updated_at, deleted_at
        `
        err := r.Db.QueryRowContext(
                ctx, query, adm.Id(), adm.FirstName(), adm.LastName(), adm.Email().Value(), adm.Password().String(), adm.Gender(), birthVal, phoneVal).Scan(
                &amp;id, &amp;firstName, &amp;lastName, &amp;email, &amp;gender, &amp;birth, &amp;phone, &amp;lastLoginAt, &amp;createdAt, &amp;updatedAt, &amp;deletedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[repository:patient][Create] error executing SQL query '%s': %v", query, err)
                return nil, fmt.Errorf("scan failed: %w", err)
        }</span>

        <span class="cov0" title="0">patient := patients.NewPatientFromDB(id, firstName, lastName, email, "", gender, birth, phone, lastLoginAt, createdAt, updatedAt, deletedAt)
        log.Printf("[repository:patient][Create] successfully created patient in DB %v", patient)
        return patient, nil</span>
}

func (r *PatientRepository) Update(ctx context.Context, adm *patients.Patient) (*patients.Patient, error) <span class="cov0" title="0">{
        var (
                id                                 uuid.UUID
                firstName, lastName, email, gender string
                phone                              *string
                lastLoginAt, createdAt, updatedAt  time.Time
                birth, deletedAt                   *time.Time
        )

        if adm.Birth() != nil </span><span class="cov0" title="0">{
                birth = adm.Birth().Value()
        }</span>

        <span class="cov0" title="0">if adm.Phone() != nil </span><span class="cov0" title="0">{
                phone = adm.Phone().String()
        }</span>

        <span class="cov0" title="0">query := `
        UPDATE patient
        SET first_name = $1, last_name = $2, email = $3, password = $4, gender = $5, birth = $6, phone = $7, last_login_at = $8, updated_at = $9 
        WHERE id = $10
        RETURNING id, first_name, last_name, email, gender, birth, phone, last_login_at, created_at, updated_at, deleted_at
    `

        err := r.Db.QueryRowContext(
                ctx,
                query,
                adm.FirstName(),
                adm.LastName(),
                adm.Email().Value(),
                adm.Password().String(),
                adm.Gender(),
                birth,
                phone,
                adm.LastLoginAt,
                adm.UpdatedAt,
                adm.Id(),
        ).Scan(
                &amp;id, &amp;firstName, &amp;lastName, &amp;email, &amp;gender, &amp;birth, &amp;phone, &amp;lastLoginAt, &amp;createdAt, &amp;updatedAt, &amp;deletedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[repository:patient][Update] error executing SQL query: %v", err)
                return nil, fmt.Errorf("scan failed: %w", err)
        }</span>

        <span class="cov0" title="0">updatedAdmin := patients.NewPatientFromDB(
                id, firstName, lastName, email, adm.Password().String(), gender, birth, phone, lastLoginAt, createdAt, updatedAt, deletedAt,
        )

        return updatedAdmin, nil</span>
}

func (r *PatientRepository) Delete(ctx context.Context, id uuid.UUID) (*patients.Patient, error) <span class="cov0" title="0">{
        var (
                idNew                              uuid.UUID
                firstName, lastName, email, gender string
                lastLoginAt, createdAt, updatedAt  time.Time
                birth, deletedAt                   *time.Time
                phone                              *string
        )

        query := `
                UPDATE patient
                SET deleted_at = NOW() 
                WHERE id = $1 
                RETURNING id, first_name, last_name, email, gender, birth, phone, last_login_at, created_at, updated_at, deleted_at
        `
        err := r.Db.QueryRowContext(ctx, query, id).Scan(
                &amp;idNew, &amp;firstName, &amp;lastName, &amp;email, &amp;gender, &amp;birth, &amp;phone, &amp;lastLoginAt, &amp;createdAt, &amp;updatedAt, &amp;deletedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[repository:patient][Delete] error executing SQL query '%s': %v", query, err)
                return nil, err
        }</span>

        <span class="cov0" title="0">patient := patients.NewPatientFromDB(id, firstName, lastName, email, "", gender, birth, phone, lastLoginAt, createdAt, updatedAt, deletedAt)
        log.Printf("[repository:patient][Delete] successfully soft deleted patient %v", patient)
        return patient, nil</span>
}

func (r *PatientRepository) Restore(ctx context.Context, id uuid.UUID) (*patients.Patient, error) <span class="cov0" title="0">{
        var (
                idNew                              uuid.UUID
                firstName, lastName, email, gender string
                lastLoginAt, createdAt, updatedAt  time.Time
                birth, deletedAt                   *time.Time
                phone                              *string
        )

        query := `
                UPDATE patient
                SET deleted_at = NULL
                WHERE id = $1
                RETURNING id, first_name, last_name, email, gender, birth, phone, last_login_at, created_at, updated_at, deleted_at
        `
        err := r.Db.QueryRowContext(ctx, query, id).Scan(
                &amp;idNew, &amp;firstName, &amp;lastName, &amp;email, &amp;gender, &amp;birth, &amp;phone, &amp;lastLoginAt, &amp;createdAt, &amp;updatedAt, &amp;deletedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[repository:patient][Restore] error executing SQL query '%s': %v", query, err)
                return nil, err
        }</span>

        <span class="cov0" title="0">patient := patients.NewPatientFromDB(id, firstName, lastName, email, "", gender, birth, phone, lastLoginAt, createdAt, updatedAt, deletedAt)
        log.Printf("[repository:patient][Delete] successfully restore patient %v", patient)
        return patient, nil</span>
}

func (r *PatientRepository) CountAll(ctx context.Context) (int, error) <span class="cov0" title="0">{
        var count int
        query := `
                SELECT COUNT(*)
                FROM patient
        `
        err := r.Db.QueryRowContext(ctx, query).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[repository:patient][CountAll] error executing SQL query in CountAll: %v", err)
                return 0, err
        }</span>
        <span class="cov0" title="0">return count, nil</span>
}

func (r *PatientRepository) CountActive(ctx context.Context) (int, error) <span class="cov0" title="0">{
        var count int
        query := `SELECT COUNT(*)
                FROM patient 
                WHERE deleted_at IS NULL
        `
        err := r.Db.QueryRowContext(ctx, query).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[repository:patient][CountActive] error executing SQL query in CountActive: %v", err)
                return 0, err
        }</span>
        <span class="cov0" title="0">return count, nil</span>
}

func (r *PatientRepository) CountDeleted(ctx context.Context) (int, error) <span class="cov0" title="0">{
        var count int
        query := `SELECT COUNT(*)
                FROM patient
                WHERE deleted_at IS NOT NULL
        `
        err := r.Db.QueryRowContext(ctx, query).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[repository:patient][CountDeleted] error executing SQL query in CountDeleted: %v", err)
                return 0, err
        }</span>
        <span class="cov0" title="0">return count, nil</span>
}

func NewPatientRepository(db *sql.DB) patients.PatientRepository <span class="cov0" title="0">{
        return &amp;PatientRepository{Db: db}
}</span>
</pre>
		
		<pre class="file" id="file55" style="display: none">package controllers

import (
        "database/sql"
        "encoding/json"
        "github.com/carlosclavijo/Nutricenter-Contracting/internal/application/administrator/commands"
        "github.com/carlosclavijo/Nutricenter-Contracting/internal/application/administrator/dto"
        command "github.com/carlosclavijo/Nutricenter-Contracting/internal/application/administrator/handlers"
        "github.com/carlosclavijo/Nutricenter-Contracting/internal/application/administrator/queries"
        "github.com/carlosclavijo/Nutricenter-Contracting/internal/domain/administrator"
        query "github.com/carlosclavijo/Nutricenter-Contracting/internal/infrastructure/handlers/administrator"
        "github.com/carlosclavijo/Nutricenter-Contracting/internal/infrastructure/persistence/repositories"
        "github.com/carlosclavijo/Nutricenter-Contracting/internal/web/helpers"
        "github.com/go-chi/chi/v5"
        "github.com/google/uuid"
        "log"
        "net/http"
        "time"
)

type AdministratorController struct {
        cmdHandler command.AdministratorHandler
        qryHandler query.AdministratorHandler
}

func NewAdministratorHandler(db *sql.DB) *AdministratorController <span class="cov0" title="0">{
        repo := repositories.NewAdministratorRepository(db)
        factory := administrators.NewAdministratorFactory()
        cmdHandler := command.NewAdministratorHandler(repo, factory)
        qryHandler := query.NewAdministratorHandler(repo, factory)
        return &amp;AdministratorController{*cmdHandler, *qryHandler}
}</span>

type adminFull struct {
        Id        uuid.UUID  `json:"id"`
        FirstName string     `json:"first_name"`
        LastName  string     `json:"last_name"`
        Email     string     `json:"email"`
        Password  string     `json:"password"`
        Gender    string     `json:"gender"`
        Birth     *time.Time `json:"birth,omitempty"`
        Phone     *string    `json:"phone,omitempty"`
        LastLogin time.Time  `json:"last_login"`
        CreatedAt time.Time  `json:"created_at"`
        UpdatedAt time.Time  `json:"updated_at"`
        DeletedAt *time.Time `json:"deleted_at,omitempty"`
}

func (h *AdministratorController) GetAllAdministrators(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        qry := queries.GetAllAdministratorsQuery{}
        admins, err := h.qryHandler.HandleGetAll(r.Context(), qry)

        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[controller:administrator][GetAllAdministrators] failed to fetch administrators: %v", err)
                writeJSON(w, http.StatusInternalServerError, helpers.Response[any]{
                        Success: false,
                        Error: &amp;helpers.Error{
                                Code:    "GET_ALL_FAILED",
                                Message: "Could not fetch administrators",
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">writeJSON(w, http.StatusOK, helpers.Response[[]dto.AdministratorDTO]{
                Success: true,
                Data:    *admins,
                Length:  len(*admins),
        })</span>
}

func (h *AdministratorController) GetListAdministrators(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        qry := queries.GetListAdministratorsQuery{}
        admins, err := h.qryHandler.HandleGetList(r.Context(), qry)

        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[controller:administrator][GetListAdministrators] failed to fetch administrators: %v", err)
                writeJSON(w, http.StatusInternalServerError, helpers.Response[any]{
                        Success: false,
                        Error: &amp;helpers.Error{
                                Code:    "GET_LIST_FAILED",
                                Message: "Could not fetch administrators",
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">writeJSON(w, http.StatusOK, helpers.Response[[]dto.AdministratorDTO]{
                Success: true,
                Data:    *admins,
                Length:  len(*admins),
        })</span>
}

func (h *AdministratorController) GetAdministratorById(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        idStr := chi.URLParam(r, "id")
        id, err := uuid.Parse(idStr)

        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[controller:administrator][GetAdministratorById] invalid UUID: %q, error: %v", idStr, err)
                writeJSON(w, http.StatusBadRequest, helpers.Response[any]{
                        Success: false,
                        Error: &amp;helpers.Error{
                                Code:    "PARSING_UUID_FAILED",
                                Message: "Could not parse UUID",
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">qry := queries.GetAdministratorByIdQuery{Id: id}
        admin, err := h.qryHandler.HandleGetById(r.Context(), qry)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[controller:administrator][GetAdministratorById] failed to retrieve administrator with ID %s: %v", id, err)
                writeJSON(w, http.StatusInternalServerError, helpers.Response[any]{
                        Success: false,
                        Error: &amp;helpers.Error{
                                Code:    "GET_BY_ID_FAILED",
                                Message: "Could not retrieve administrator",
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">writeJSON(w, http.StatusOK, helpers.Response[dto.AdministratorDTO]{
                Success: true,
                Data:    *admin,
        })</span>
}

func (h *AdministratorController) GetAdministratorByEmail(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        email := chi.URLParam(r, "email")
        qry := queries.GetAdministratorByEmailQuery{Email: email}
        admin, err := h.qryHandler.HandleGetByEmail(r.Context(), qry)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[controller:administrator][GetAdministratorByEmail] failed to retrieve administrator with Email '%s': %v", email, err)
                _ = json.NewEncoder(w).Encode(helpers.Response[any]{
                        Success: false,
                        Error: &amp;helpers.Error{
                                Code:    "GET_BY_EMAIL_FAILED",
                                Message: "Could not retrieve administrator",
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">admFull := mapToAdminFull(admin)
        writeJSON(w, http.StatusOK, helpers.Response[adminFull]{
                Success: true,
                Data:    admFull,
        })</span>
}

func (h *AdministratorController) ExistAdministratorById(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        idStr := chi.URLParam(r, "id")
        id, err := uuid.Parse(idStr)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[controller:administrator][ExistAdministratorById] invalid UUID: %q, error: %v", idStr, err)
                writeJSON(w, http.StatusBadRequest, helpers.Response[any]{
                        Success: false,
                        Error: &amp;helpers.Error{
                                Code:    "PARSING_UUID_FAILED",
                                Message: "Could not parse UUID",
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">qry := queries.ExistAdministratorByIdQuery{Id: id}
        exist, err := h.qryHandler.HandleExistById(r.Context(), qry)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[controller:administrator][ExistAdministratorById] failed to retrieve if the administrator exists with ID %s: %v", id, err)
                writeJSON(w, http.StatusInternalServerError, helpers.Response[any]{
                        Success: false,
                        Error: &amp;helpers.Error{
                                Code:    "EXISTS_BY_ID_FAILED",
                                Message: "Could not retrieve if administrator exists or not",
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">writeJSON(w, http.StatusOK, helpers.Response[bool]{
                Success: true,
                Data:    exist,
        })</span>
}

func (h *AdministratorController) ExistAdministratorByEmail(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        email := chi.URLParam(r, "email")
        qry := queries.ExistAdministratorByEmailQuery{Email: email}

        exist, err := h.qryHandler.HandleExistByEmail(r.Context(), qry)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[controller:administrator][ExistAdministratorByEmail] failed to retrieve if the administrator exists with email %s: %v", email, err)
                writeJSON(w, http.StatusInternalServerError, helpers.Response[any]{
                        Success: false,
                        Error: &amp;helpers.Error{
                                Code:    "EXIST_BY_EMAIL_FAILED",
                                Message: "Could not retrieve if administrator exists or not",
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">writeJSON(w, http.StatusOK, helpers.Response[bool]{
                Success: true,
                Data:    exist,
        })</span>
}

func (h *AdministratorController) LoginAdministrator(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req struct {
                Email    string `json:"email"`
                Password string `json:"password"`
        }

        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                log.Printf("[controller:administrator][Login] failed to decode request body: %v", err)
                writeJSON(w, http.StatusBadRequest, helpers.Response[any]{
                        Success: false,
                        Error: &amp;helpers.Error{
                                Code:    "INVALID_REQUEST_BODY",
                                Message: "Invalid JSON format or fields",
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">qry := commands.LoginAdministratorCommand{
                Email:    req.Email,
                Password: req.Password,
        }

        admin, err := h.cmdHandler.HandleLogin(r.Context(), qry)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[controller:administrator][Login] failed to retrieve administrator with Email '%s': %v", req.Email, err)
                writeJSON(w, http.StatusBadRequest, helpers.Response[any]{
                        Success: false,
                        Error: &amp;helpers.Error{
                                Code:    "LOGIN_FAILED",
                                Message: "Could not retrieve administrator",
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">writeJSON(w, http.StatusOK, helpers.Response[administrators.Administrator]{
                Success: true,
                Data:    *admin,
        })</span>
}

func (h *AdministratorController) CreateAdministrator(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req struct {
                FirstName string     `json:"first_name"`
                LastName  string     `json:"last_name"`
                Email     string     `json:"email"`
                Password  string     `json:"password"`
                Gender    string     `json:"gender"`
                Birth     *time.Time `json:"birth"`
                Phone     *string    `json:"phone"`
        }

        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                log.Printf("[controller:administrator][CreateAdministrator] failed to decode request body '%v': %v", req, err)
                writeJSON(w, http.StatusBadRequest, helpers.Response[any]{
                        Success: false,
                        Error: &amp;helpers.Error{
                                Code:    "INVALID_REQUEST_BODY",
                                Message: "Invalid JSON format or fields",
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">cmd := commands.CreateAdministratorCommand{
                FirstName: req.FirstName,
                LastName:  req.LastName,
                Email:     req.Email,
                Password:  req.Password,
                Gender:    req.Gender,
                Birth:     req.Birth,
                Phone:     req.Phone,
        }

        admin, err := h.cmdHandler.HandleCreate(r.Context(), cmd)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[controller:administrator][CreateAdministrator] failed to create administrator with command '%v': %v", admin, err)
                writeJSON(w, http.StatusInternalServerError, helpers.Response[any]{
                        Success: false,
                        Error: &amp;helpers.Error{
                                Code:    "CREATE_FAILED",
                                Message: "Could not create administrator",
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">admFull := mapToAdminFull(admin)
        writeJSON(w, http.StatusCreated, helpers.Response[adminFull]{
                Success: true,
                Data:    admFull,
        })</span>
}

func (h *AdministratorController) UpdateAdministrator(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req struct {
                Id        string     `json:"id"`
                FirstName string     `json:"first_name,omitempty"`
                LastName  string     `json:"last_name,omitempty"`
                Email     string     `json:"email,omitempty"`
                Password  string     `json:"password,omitempty"`
                Gender    string     `json:"gender,omitempty"`
                Birth     *time.Time `json:"birth,omitempty"`
                Phone     *string    `json:"phone,omitempty"`
        }

        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                log.Printf("[controller:administrator][UpdateAdministrator] failed to decode request body: %v", err)
                writeJSON(w, http.StatusBadRequest, helpers.Response[any]{
                        Success: false,
                        Error: &amp;helpers.Error{
                                Code:    "INVALID_REQUEST_BODY",
                                Message: "Invalid JSON format or fields",
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">uid, err := uuid.Parse(req.Id)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[controller:administrator][UpdateAdministrator] invalid UUID '%s', error: %v", req.Id, err)
                writeJSON(w, http.StatusBadRequest, helpers.Response[any]{
                        Success: false,
                        Error: &amp;helpers.Error{
                                Code:    "INVALID_UUID_PARSING",
                                Message: "Could not parse UUID",
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">cmd := commands.UpdateAdministratorCommand{
                Id:        uid,
                FirstName: req.FirstName,
                LastName:  req.LastName,
                Email:     req.Email,
                Password:  req.Password,
                Birth:     req.Birth,
                Phone:     req.Phone,
        }

        admin, err := h.cmdHandler.HandleUpdate(r.Context(), cmd)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[controller:administrator][UpdateAdministrator] failed to update administrator with ID %s: %v", uid, err)
                writeJSON(w, http.StatusInternalServerError, helpers.Response[any]{
                        Success: false,
                        Error: &amp;helpers.Error{
                                Code:    "UPDATE_FAILED",
                                Message: "Could not update administrator",
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">admFull := mapToAdminFull(admin)
        writeJSON(w, http.StatusOK, helpers.Response[adminFull]{
                Success: true,
                Data:    admFull,
        })</span>
}

func (h *AdministratorController) DeleteAdministrator(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        idStr := chi.URLParam(r, "id")
        id, err := uuid.Parse(idStr)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[controller:administrator][DeleteAdministrator] invalid UUID: %q, error: %v", idStr, err)
                writeJSON(w, http.StatusBadRequest, helpers.Response[any]{
                        Success: false,
                        Error: &amp;helpers.Error{
                                Code:    "PARSING_UUID_FAILED",
                                Message: "Could not parse UUID",
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">admin, err := h.cmdHandler.HandleDelete(r.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[controller:administrator][DeleteAdministrator] failed to delete administrator with ID %s: %v", id, err)
                writeJSON(w, http.StatusInternalServerError, helpers.Response[any]{
                        Success: false,
                        Error: &amp;helpers.Error{
                                Code:    "DELETE_FAILED",
                                Message: "Could not delete administrator",
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">admFull := mapToAdminFull(admin)
        writeJSON(w, http.StatusOK, helpers.Response[adminFull]{
                Success: true,
                Data:    admFull,
        })</span>
}

func (h *AdministratorController) RestoreAdministrator(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        idStr := chi.URLParam(r, "id")
        id, err := uuid.Parse(idStr)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[controller:administrator][RestoreAdministrator] invalid UUID: %q, error: %v", idStr, err)
                writeJSON(w, http.StatusBadRequest, helpers.Response[any]{
                        Success: false,
                        Error: &amp;helpers.Error{
                                Code:    "PARSING_UUID_FAILED",
                                Message: "Could not parse UUID",
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">admin, err := h.cmdHandler.HandleRestore(r.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[controller:administrator][RestoreAdministrator] failed to restore administrator with ID %s: %v", id, err)
                writeJSON(w, http.StatusInternalServerError, helpers.Response[any]{
                        Success: false,
                        Error: &amp;helpers.Error{
                                Code:    "RESTORE_FAILED",
                                Message: "Could not restore administrator",
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">admFull := mapToAdminFull(admin)
        writeJSON(w, http.StatusOK, helpers.Response[adminFull]{
                Success: true,
                Data:    admFull,
        })</span>
}

func (h *AdministratorController) CountAllAdministrators(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        qry := queries.CountAllAdministratorsQuery{}
        count, err := h.qryHandler.HandleCountAll(r.Context(), qry)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[controller:administrator][CountAllAdministrators] failed to get quantity: %v", err)
                writeJSON(w, http.StatusInternalServerError, helpers.Response[any]{
                        Success: false,
                        Error: &amp;helpers.Error{
                                Code:    "COUNT_ALL_FAILED",
                                Message: "Could not get quantity",
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">writeJSON(w, http.StatusOK, helpers.Response[int]{
                Success: true,
                Length:  count,
        })</span>
}

func (h *AdministratorController) CountActiveAdministrators(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        qry := queries.CountActiveAdministratorsQuery{}
        count, err := h.qryHandler.HandleCountActive(r.Context(), qry)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[controller:administrator][CountActiveAdministrators] failed to get quantity: %v", err)
                writeJSON(w, http.StatusInternalServerError, helpers.Response[any]{
                        Success: false,
                        Error: &amp;helpers.Error{
                                Code:    "COUNT_ACTIVE_FAILED",
                                Message: "Could not get quantity",
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">writeJSON(w, http.StatusOK, helpers.Response[int]{
                Success: true,
                Length:  count,
        })</span>
}

func (h *AdministratorController) CountDeletedAdministrators(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        qry := queries.CountDeletedAdministratorsQuery{}
        count, err := h.qryHandler.HandleCountDeleted(r.Context(), qry)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[controller:administrator][CountDeletedAdministrators] failed to get quantity: %v", err)
                writeJSON(w, http.StatusInternalServerError, helpers.Response[any]{
                        Success: false,
                        Error: &amp;helpers.Error{
                                Code:    "COUNT_DELETED_FAILED",
                                Message: "Could not get quantity",
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">writeJSON(w, http.StatusOK, helpers.Response[int]{
                Success: true,
                Length:  count,
        })</span>
}

func writeJSON(w http.ResponseWriter, status int, payload any) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(status)
        if err := json.NewEncoder(w).Encode(payload); err != nil </span><span class="cov0" title="0">{
                log.Printf("failed to encode response: %v", err)
                http.Error(w, "Failed to encode response", http.StatusInternalServerError)
        }</span>
}

func mapToAdminFull(admin *administrators.Administrator) adminFull <span class="cov0" title="0">{
        var birthTm *time.Time
        if admin.Birth() != nil </span><span class="cov0" title="0">{
                b := admin.Birth().Value()
                birthTm = b
        }</span>

        <span class="cov0" title="0">var phoneStr *string
        if admin.Phone() != nil </span><span class="cov0" title="0">{
                p := admin.Phone().String()
                phoneStr = p
        }</span>

        <span class="cov0" title="0">return adminFull{
                Id:        admin.Id(),
                FirstName: admin.FirstName(),
                LastName:  admin.LastName(),
                Email:     admin.Email().Value(),
                Password:  "",
                Gender:    admin.Gender(),
                Birth:     birthTm,
                Phone:     phoneStr,
                LastLogin: admin.LastLoginAt,
                CreatedAt: admin.CreatedAt(),
                UpdatedAt: admin.UpdatedAt,
                DeletedAt: admin.DeletedAt,
        }</span>
}

func (h *AdministratorController) RegisterRoutes(r chi.Router) <span class="cov0" title="0">{
        r.Get("/all", h.GetAllAdministrators)
        r.Get("/list", h.GetListAdministrators)
        r.Get("/email/{email}", h.GetAdministratorByEmail)
        r.Get("/exist/id/{id}", h.ExistAdministratorById)
        r.Get("/exist/email/{email}", h.ExistAdministratorByEmail)
        r.Get("/count/all", h.CountAllAdministrators)
        r.Get("/count/active", h.CountActiveAdministrators)
        r.Get("/count/deleted", h.CountDeletedAdministrators)
        r.Get("/{id}", h.GetAdministratorById)
        r.Post("/", h.CreateAdministrator)
        r.Post("/login", h.LoginAdministrator)
        r.Put("/", h.UpdateAdministrator)
        r.Patch("/", h.RestoreAdministrator)
        r.Delete("/{id}", h.DeleteAdministrator)
}</span>
</pre>
		
		<pre class="file" id="file56" style="display: none">package controllers

import (
        "database/sql"
        "encoding/json"
        "github.com/carlosclavijo/Nutricenter-Contracting/internal/application/patient/commands"
        "github.com/carlosclavijo/Nutricenter-Contracting/internal/application/patient/dto"
        command "github.com/carlosclavijo/Nutricenter-Contracting/internal/application/patient/handlers"
        "github.com/carlosclavijo/Nutricenter-Contracting/internal/application/patient/queries"
        "github.com/carlosclavijo/Nutricenter-Contracting/internal/domain/patient"
        query "github.com/carlosclavijo/Nutricenter-Contracting/internal/infrastructure/handlers/patient"
        "github.com/carlosclavijo/Nutricenter-Contracting/internal/infrastructure/persistence/repositories"
        "github.com/carlosclavijo/Nutricenter-Contracting/internal/web/helpers"
        "github.com/go-chi/chi/v5"
        "github.com/google/uuid"
        "log"
        "net/http"
        "time"
)

type PatientController struct {
        cmdHandler command.PatientHandler
        qryHandler query.PatientHandler
}

func NewPatientHandler(db *sql.DB) *PatientController <span class="cov0" title="0">{
        repo := repositories.NewPatientRepository(db)
        factory := patients.NewPatientFactory()
        cmdHandler := command.NewPatientHandler(repo, factory)
        qryHandler := query.NewPatientHandler(repo, factory)
        return &amp;PatientController{*cmdHandler, *qryHandler}
}</span>

type patientFull struct {
        Id        uuid.UUID  `json:"id"`
        FirstName string     `json:"first_name"`
        LastName  string     `json:"last_name"`
        Email     string     `json:"email"`
        Password  string     `json:"password,omitempty"`
        Gender    string     `json:"gender"`
        Birth     *time.Time `json:"birth,omitempty"`
        Phone     *string    `json:"phone,omitempty"`
        LastLogin time.Time  `json:"last_login"`
        CreatedAt time.Time  `json:"created_at"`
        UpdatedAt time.Time  `json:"updated_at"`
        DeletedAt *time.Time `json:"deleted_at,omitempty"`
}

func (h *PatientController) GetAllPatients(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        qry := queries.GetAllPatientsQuery{}
        ptnts, err := h.qryHandler.HandleGetAll(r.Context(), qry)

        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[controller:patient][GetAllPatients] failed to fetch patients: %v", err)
                writeJSON(w, http.StatusInternalServerError, helpers.Response[any]{
                        Success: false,
                        Error: &amp;helpers.Error{
                                Code:    "GET_ALL_FAILED",
                                Message: "Could not fetch patients",
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">writeJSON(w, http.StatusOK, helpers.Response[[]dto.PatientDTO]{
                Success: true,
                Data:    *ptnts,
                Length:  len(*ptnts),
        })</span>
}

func (h *PatientController) GetListPatients(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        qry := queries.GetListPatientsQuery{}
        ptnts, err := h.qryHandler.HandleGetList(r.Context(), qry)

        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[controller:patient][GetListPatients] failed to fetch patients: %v", err)
                writeJSON(w, http.StatusInternalServerError, helpers.Response[any]{
                        Success: false,
                        Error: &amp;helpers.Error{
                                Code:    "GET_LIST_FAILED",
                                Message: "Could not fetch patients",
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">writeJSON(w, http.StatusOK, helpers.Response[[]dto.PatientDTO]{
                Success: true,
                Data:    *ptnts,
                Length:  len(*ptnts),
        })</span>
}

func (h *PatientController) GetPatientById(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        idStr := chi.URLParam(r, "id")
        id, err := uuid.Parse(idStr)

        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[controller:patient][GetPatientById] invalid UUID: %q, error: %v", idStr, err)
                writeJSON(w, http.StatusBadRequest, helpers.Response[any]{
                        Success: false,
                        Error: &amp;helpers.Error{
                                Code:    "PARSING_UUID_FAILED",
                                Message: "Could not parse UUID",
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">qry := queries.GetPatientByIdQuery{Id: id}
        ptnt, err := h.qryHandler.HandleGetById(r.Context(), qry)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[controller:patient][GetPatientById] failed to retrieve patient with ID %s: %v", id, err)
                writeJSON(w, http.StatusInternalServerError, helpers.Response[any]{
                        Success: false,
                        Error: &amp;helpers.Error{
                                Code:    "GET_BY_ID_FAILED",
                                Message: "Could not retrieve patient",
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">writeJSON(w, http.StatusOK, helpers.Response[dto.PatientDTO]{
                Success: true,
                Data:    *ptnt,
        })</span>
}

func (h *PatientController) GetPatientByEmail(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        email := chi.URLParam(r, "email")
        qry := queries.GetPatientByEmailQuery{Email: email}
        ptnt, err := h.qryHandler.HandleGetByEmail(r.Context(), qry)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[controller:patient][GetPatientByEmail] failed to retrieve patient with Email '%s': %v", email, err)
                _ = json.NewEncoder(w).Encode(helpers.Response[any]{
                        Success: false,
                        Error: &amp;helpers.Error{
                                Code:    "GET_BY_EMAIL_FAILED",
                                Message: "Could not retrieve patient",
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">ptnFull := mapToPatientFull(ptnt)
        writeJSON(w, http.StatusOK, helpers.Response[patientFull]{
                Success: true,
                Data:    ptnFull,
        })</span>
}

func (h *PatientController) ExistPatientById(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        idStr := chi.URLParam(r, "id")
        id, err := uuid.Parse(idStr)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[controller:patient][ExistPatientById] invalid UUID: %q, error: %v", idStr, err)
                writeJSON(w, http.StatusBadRequest, helpers.Response[any]{
                        Success: false,
                        Error: &amp;helpers.Error{
                                Code:    "PARSING_UUID_FAILED",
                                Message: "Could not parse UUID",
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">qry := queries.ExistPatientByIdQuery{Id: id}
        exist, err := h.qryHandler.HandleExistById(r.Context(), qry)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[controller:patient][ExistPatientById] failed to retrieve if the patient exists with ID %s: %v", id, err)
                writeJSON(w, http.StatusInternalServerError, helpers.Response[any]{
                        Success: false,
                        Error: &amp;helpers.Error{
                                Code:    "EXISTS_BY_ID_FAILED",
                                Message: "Could not retrieve if patient exists or not",
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">writeJSON(w, http.StatusOK, helpers.Response[bool]{
                Success: true,
                Data:    exist,
        })</span>
}

func (h *PatientController) ExistPatientByEmail(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        email := chi.URLParam(r, "email")
        qry := queries.ExistPatientByEmailQuery{Email: email}

        exist, err := h.qryHandler.HandleExistByEmail(r.Context(), qry)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[controller:patient][ExistPatientByEmail] failed to retrieve if the patient exists with email %s: %v", email, err)
                writeJSON(w, http.StatusInternalServerError, helpers.Response[any]{
                        Success: false,
                        Error: &amp;helpers.Error{
                                Code:    "EXIST_BY_EMAIL_FAILED",
                                Message: "Could not retrieve if patient exists or not",
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">writeJSON(w, http.StatusOK, helpers.Response[bool]{
                Success: true,
                Data:    exist,
        })</span>
}

func (h *PatientController) LoginPatient(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req struct {
                Email    string `json:"email"`
                Password string `json:"password"`
        }

        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                log.Printf("[controller:patient][Login] failed to decode request body: %v", err)
                writeJSON(w, http.StatusBadRequest, helpers.Response[any]{
                        Success: false,
                        Error: &amp;helpers.Error{
                                Code:    "INVALID_REQUEST_BODY",
                                Message: "Invalid JSON format or fields",
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">qry := commands.LoginPatientCommand{
                Email:    req.Email,
                Password: req.Password,
        }

        ptnt, err := h.cmdHandler.HandleLogin(r.Context(), qry)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[controller:patient][Login] failed to retrieve patient with Email '%s': %v", req.Email, err)
                writeJSON(w, http.StatusBadRequest, helpers.Response[any]{
                        Success: false,
                        Error: &amp;helpers.Error{
                                Code:    "LOGIN_FAILED",
                                Message: "Could not retrieve patient",
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">writeJSON(w, http.StatusOK, helpers.Response[patients.Patient]{
                Success: true,
                Data:    *ptnt,
        })</span>
}

func (h *PatientController) CreatePatient(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req struct {
                FirstName string     `json:"first_name"`
                LastName  string     `json:"last_name"`
                Email     string     `json:"email"`
                Password  string     `json:"password"`
                Gender    string     `json:"gender"`
                Birth     *time.Time `json:"birth"`
                Phone     *string    `json:"phone"`
        }

        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                log.Printf("[controller:patient][CreatePatient] failed to decode request body '%v': %v", req, err)
                writeJSON(w, http.StatusBadRequest, helpers.Response[any]{
                        Success: false,
                        Error: &amp;helpers.Error{
                                Code:    "INVALID_REQUEST_BODY",
                                Message: "Invalid JSON format or fields",
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">cmd := commands.CreatePatientCommand{
                FirstName: req.FirstName,
                LastName:  req.LastName,
                Email:     req.Email,
                Password:  req.Password,
                Gender:    req.Gender,
                Birth:     req.Birth,
                Phone:     req.Phone,
        }

        ptnt, err := h.cmdHandler.HandleCreate(r.Context(), cmd)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[controller:patient][CreatePatient] failed to create patient with command '%v': %v", ptnt, err)
                writeJSON(w, http.StatusInternalServerError, helpers.Response[any]{
                        Success: false,
                        Error: &amp;helpers.Error{
                                Code:    "CREATE_FAILED",
                                Message: "Could not create patient",
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">ptntFull := mapToPatientFull(ptnt)
        writeJSON(w, http.StatusCreated, helpers.Response[patientFull]{
                Success: true,
                Data:    ptntFull,
        })</span>
}

func (h *PatientController) UpdatePatient(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req struct {
                Id        string     `json:"id"`
                FirstName string     `json:"first_name,omitempty"`
                LastName  string     `json:"last_name,omitempty"`
                Email     string     `json:"email,omitempty"`
                Password  string     `json:"password,omitempty"`
                Gender    string     `json:"gender,omitempty"`
                Birth     *time.Time `json:"birth,omitempty"`
                Phone     *string    `json:"phone,omitempty"`
        }

        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                log.Printf("[controller:patient][UpdatePatient] failed to decode request body: %v", err)
                writeJSON(w, http.StatusBadRequest, helpers.Response[any]{
                        Success: false,
                        Error: &amp;helpers.Error{
                                Code:    "INVALID_REQUEST_BODY",
                                Message: "Invalid JSON format or fields",
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">uid, err := uuid.Parse(req.Id)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[controller:patient][UpdatePatient] invalid UUID '%s', error: %v", req.Id, err)
                writeJSON(w, http.StatusBadRequest, helpers.Response[any]{
                        Success: false,
                        Error: &amp;helpers.Error{
                                Code:    "INVALID_UUID_PARSING",
                                Message: "Could not parse UUID",
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">cmd := commands.UpdatePatientCommand{
                Id:        uid,
                FirstName: req.FirstName,
                LastName:  req.LastName,
                Email:     req.Email,
                Password:  req.Password,
                Birth:     req.Birth,
                Phone:     req.Phone,
        }

        ptnt, err := h.cmdHandler.HandleUpdate(r.Context(), cmd)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[controller:patient][UpdatePatient] failed to update patient with ID %s: %v", uid, err)
                writeJSON(w, http.StatusInternalServerError, helpers.Response[any]{
                        Success: false,
                        Error: &amp;helpers.Error{
                                Code:    "UPDATE_FAILED",
                                Message: "Could not update patient",
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">ptntFull := mapToPatientFull(ptnt)
        writeJSON(w, http.StatusOK, helpers.Response[patientFull]{
                Success: true,
                Data:    ptntFull,
        })</span>
}

func (h *PatientController) DeletePatient(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        idStr := chi.URLParam(r, "id")
        id, err := uuid.Parse(idStr)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[controller:patient][DeletePatient] invalid UUID: %q, error: %v", idStr, err)
                writeJSON(w, http.StatusBadRequest, helpers.Response[any]{
                        Success: false,
                        Error: &amp;helpers.Error{
                                Code:    "PARSING_UUID_FAILED",
                                Message: "Could not parse UUID",
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">ptnt, err := h.cmdHandler.HandleDelete(r.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[controller:patient][DeletePatient] failed to delete patient with ID %s: %v", id, err)
                writeJSON(w, http.StatusInternalServerError, helpers.Response[any]{
                        Success: false,
                        Error: &amp;helpers.Error{
                                Code:    "DELETE_FAILED",
                                Message: "Could not delete patient",
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">pntnFull := mapToPatientFull(ptnt)
        writeJSON(w, http.StatusOK, helpers.Response[patientFull]{
                Success: true,
                Data:    pntnFull,
        })</span>
}

func (h *PatientController) RestorePatient(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        idStr := chi.URLParam(r, "id")
        id, err := uuid.Parse(idStr)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[controller:patient][RestorePatient] invalid UUID: %q, error: %v", idStr, err)
                writeJSON(w, http.StatusBadRequest, helpers.Response[any]{
                        Success: false,
                        Error: &amp;helpers.Error{
                                Code:    "PARSING_UUID_FAILED",
                                Message: "Could not parse UUID",
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">ptnt, err := h.cmdHandler.HandleRestore(r.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[controller:patient][RestorePatient] failed to restore patient with ID %s: %v", id, err)
                writeJSON(w, http.StatusInternalServerError, helpers.Response[any]{
                        Success: false,
                        Error: &amp;helpers.Error{
                                Code:    "RESTORE_FAILED",
                                Message: "Could not restore patient",
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">pntnFull := mapToPatientFull(ptnt)
        writeJSON(w, http.StatusOK, helpers.Response[patientFull]{
                Success: true,
                Data:    pntnFull,
        })</span>
}

func (h *PatientController) CountAllPatients(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        qry := queries.CountAllPatientsQuery{}
        count, err := h.qryHandler.HandleCountAll(r.Context(), qry)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[controller:patient][CountAllPatients] failed to get quantity: %v", err)
                writeJSON(w, http.StatusInternalServerError, helpers.Response[any]{
                        Success: false,
                        Error: &amp;helpers.Error{
                                Code:    "COUNT_ALL_FAILED",
                                Message: "Could not get quantity",
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">writeJSON(w, http.StatusOK, helpers.Response[int]{
                Success: true,
                Length:  count,
        })</span>
}

func (h *PatientController) CountActivePatients(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        qry := queries.CountActivePatientsQuery{}
        count, err := h.qryHandler.HandleCountActive(r.Context(), qry)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[controller:patient][CountActivePatients] failed to get quantity: %v", err)
                writeJSON(w, http.StatusInternalServerError, helpers.Response[any]{
                        Success: false,
                        Error: &amp;helpers.Error{
                                Code:    "COUNT_ACTIVE_FAILED",
                                Message: "Could not get quantity",
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">writeJSON(w, http.StatusOK, helpers.Response[int]{
                Success: true,
                Length:  count,
        })</span>
}

func (h *PatientController) CountDeletedPatients(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        qry := queries.CountDeletedPatientsQuery{}
        count, err := h.qryHandler.HandleCountDeleted(r.Context(), qry)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[controller:patient][CountDeletedPatients] failed to get quantity: %v", err)
                writeJSON(w, http.StatusInternalServerError, helpers.Response[any]{
                        Success: false,
                        Error: &amp;helpers.Error{
                                Code:    "COUNT_DELETED_FAILED",
                                Message: "Could not get quantity",
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">writeJSON(w, http.StatusOK, helpers.Response[int]{
                Success: true,
                Length:  count,
        })</span>
}

func mapToPatientFull(admin *patients.Patient) patientFull <span class="cov0" title="0">{
        var birthTm *time.Time
        if admin.Birth() != nil </span><span class="cov0" title="0">{
                b := admin.Birth().Value()
                birthTm = b
        }</span>

        <span class="cov0" title="0">var phoneStr *string
        if admin.Phone() != nil </span><span class="cov0" title="0">{
                p := admin.Phone().String()
                phoneStr = p
        }</span>

        <span class="cov0" title="0">return patientFull{
                Id:        admin.Id(),
                FirstName: admin.FirstName(),
                LastName:  admin.LastName(),
                Email:     admin.Email().Value(),
                Password:  "",
                Gender:    admin.Gender(),
                Birth:     birthTm,
                Phone:     phoneStr,
                LastLogin: admin.LastLoginAt,
                CreatedAt: admin.CreatedAt(),
                UpdatedAt: admin.UpdatedAt,
                DeletedAt: admin.DeletedAt,
        }</span>
}

func (h *PatientController) RegisterRoutes(r chi.Router) <span class="cov0" title="0">{
        r.Get("/all", h.GetAllPatients)
        r.Get("/list", h.GetListPatients)
        r.Get("/email/{email}", h.GetPatientByEmail)
        r.Get("/exist/id/{id}", h.ExistPatientById)
        r.Get("/exist/email/{email}", h.ExistPatientByEmail)
        r.Get("/count/all", h.CountAllPatients)
        r.Get("/count/active", h.CountActivePatients)
        r.Get("/count/deleted", h.CountDeletedPatients)
        r.Get("/{id}", h.GetPatientById)
        r.Post("/", h.CreatePatient)
        r.Post("/login", h.LoginPatient)
        r.Put("/", h.UpdatePatient)
        r.Patch("/", h.RestorePatient)
        r.Delete("/{id}", h.DeletePatient)
}</span>
</pre>
		
		<pre class="file" id="file57" style="display: none">package web

import (
        "database/sql"
        administrator "github.com/carlosclavijo/Nutricenter-Contracting/internal/web/controllers"
        "github.com/go-chi/chi/v5"
)

type Routes struct {
        AdministratorController *administrator.AdministratorController
        PatientController       *administrator.PatientController
}

func NewRoutes(db *sql.DB) *Routes <span class="cov0" title="0">{
        return &amp;Routes{
                AdministratorController: administrator.NewAdministratorHandler(db),
                PatientController:       administrator.NewPatientHandler(db),
        }
}</span>

func (r *Routes) Router() chi.Router <span class="cov0" title="0">{
        mux := chi.NewRouter()

        mux.Route("/administrators", r.AdministratorController.RegisterRoutes)
        mux.Route("/patients", r.PatientController.RegisterRoutes)

        return mux
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
